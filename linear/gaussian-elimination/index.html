<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="og:site_name" content="Ramble Ramble"/><link rel="canonical" href="blog.ehudadler.com/linear/gaussian-elimination"/><meta name="twitter:url" content="blog.ehudadler.com/linear/gaussian-elimination"/><meta name="og:url" content="blog.ehudadler.com/linear/gaussian-elimination"/><title>1.2 Gaussian Elimination | Ramble Ramble</title><meta name="twitter:title" content="1.2 Gaussian Elimination | Ramble Ramble"/><meta name="og:title" content="1.2 Gaussian Elimination | Ramble Ramble"/><meta name="description" content="Adding gaussian elimination to our matrix class"/><meta name="twitter:description" content="Adding gaussian elimination to our matrix class"/><meta name="og:description" content="Adding gaussian elimination to our matrix class"/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/styles.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/favicon.png" type="image/png"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to Ramble Ramble"/></head><body class="item-page"><header><div class="wrapper"><a class="site-name" href="/">Ramble Ramble</a><p>Learning everyday</p><nav><ul><li><a href="/general">General</a></li><li><a class="selected" href="/linear">Linear Algebra</a></li><li><a href="/interview">Interview Questions</a></li><li><a href="/bigdata">Algorithms for Big Data</a></li><li><a href="/finance">Finance and Economics</a></li><li><a href="/swift">Swift Compiler</a></li></ul></nav></div></header><div class="wrapper"><article><div class="content"><p>Welcome back. If you're here for the first time I suggest reading from the beginning of the series (<a href="https://blog.ehudadler.com/linear/matrix/">over here</a>).</p><p>I also suggest reading all my blog posts though...</p><h1>Recap</h1><p>I feel like starting off each post in this series with a recap is a good idea.</p><p>Last time we outlined and built the beginning stages of our Matrix class. A matrix is a just a 2d grid filled with numbers. It's always weird recapping your work and remembering that it took like 3 hours to produce but 1 sentence to summarize. I guess what I'm saying is, that's the recap. Onto the main event.</p><h1>1.2 Gaussian Elimination</h1><p>I believe at the end of the last post (yup confirmed) I mentioned this post would deal with gaussian elimination. I've though about it a bit since then and am excited to give this a try.</p><h2>What is Gaussian Elimination?</h2><p>Let's say you're presented with the following problem on a test:</p><html><header><script type="text/x-mathjax-config">MathJax.Hub.Config({jax: ["input/TeX","output/HTML-CSS"], tex2jax: {inlineMath: [['$$','$$']]} , "HTML-CSS": {linebreaks: {automatic: true}}});</script><script src='https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script></header><body>$$
\begin{align}
3x + 8y &= 13\\
6x + 32y &= 84
\end{align}
$$</body></html><p>and asked to find what values you should set x and y to in order to make the equation evaluate to true.</p><p>You may start by inspecting the two equations and testing some values. More likely you will solve one equation (let's say the first one) so that one variable (x for example) is in terms of y. Something like:</p><html><header><script type="text/x-mathjax-config">MathJax.Hub.Config({jax: ["input/TeX","output/HTML-CSS"], tex2jax: {inlineMath: [['$$','$$']]} , "HTML-CSS": {linebreaks: {automatic: true}}});</script><script src='https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script></header><body>$$
\begin{align}
    3x + 8y &= 13 \\
    3x &= 8y + 13 \\
    x &= \frac{8y + 13}{3}
\end{align}
$$</body></html><p>Now you can replace x with</p><html><header><script type="text/x-mathjax-config">MathJax.Hub.Config({jax: ["input/TeX","output/HTML-CSS"], tex2jax: {inlineMath: [['$$','$$']]} , "HTML-CSS": {linebreaks: {automatic: true}}});</script><script src='https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script></header><body>$$
\frac{8y + 13}{3}
$$</body></html><p>and solve regularly. This approach works well when you have 2 equations and 2 unknowns, but what happens with the following:</p><html><header><script type="text/x-mathjax-config">MathJax.Hub.Config({jax: ["input/TeX","output/HTML-CSS"], tex2jax: {inlineMath: [['$$','$$']]} , "HTML-CSS": {linebreaks: {automatic: true}}});</script><script src='https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script></header><body>$$
\begin{align}
3x + 8y - 54z &= 13\\
6x + 32y + z &= 84\\
91x + 82y + 9z &= 344\\
13x + 5y + 8z &= 91\\
\end{align}
$$</body></html><p>Whether or not this has a solution (I have no clue) solving it via substitution is much harder.</p><p>Introducing Gaussian Elimination. Gaussian Elimination is one method for making progress on a problem like this.</p><h2>How Gaussian Elimination Works</h2><p>First off, Gaussian Elimination works on a Matrix. So given our system of equations</p><html><header><script type="text/x-mathjax-config">MathJax.Hub.Config({jax: ["input/TeX","output/HTML-CSS"], tex2jax: {inlineMath: [['$$','$$']]} , "HTML-CSS": {linebreaks: {automatic: true}}});</script><script src='https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script></header><body>$$
\begin{align}
3x + 8y - 54z &= 13\\
6x + 32y + z &= 84\\
91x + 82y + 9z &= 344\\
13x + 5y + 8z &= 91\\
\end{align}
$$</body></html><p>we must produce the matrix:</p><html><header><script type="text/x-mathjax-config">MathJax.Hub.Config({jax: ["input/TeX","output/HTML-CSS"], tex2jax: {inlineMath: [['$$','$$']]} , "HTML-CSS": {linebreaks: {automatic: true}}});</script><script src='https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script></header><body>$$
\begin{bmatrix}
3 & 8 & -54 & 13\\
6 & 32 & 1 & 84\\
91 & 82 & 9 & 344\\
13 & 5 & 8 & 91\\
\end{bmatrix}
$$</body></html><p>Now that we have our matrix, we can discuss the rules.</p><p>There are 3 valid moves you can make while performing Gaussian Elimination</p><ol><li>Swap 2 rows</li><li>Subtract one row by k times another row</li><li>Multiple through a row by k</li></ol><p>For example I can swap row 0 and row 1 and get:</p><html><header><script type="text/x-mathjax-config">MathJax.Hub.Config({jax: ["input/TeX","output/HTML-CSS"], tex2jax: {inlineMath: [['$$','$$']]} , "HTML-CSS": {linebreaks: {automatic: true}}});</script><script src='https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script></header><body>$$
\begin{bmatrix}
6 & 32 & 1 & 84\\
3 & 8 & -54 & 13\\
91 & 82 & 9 & 344\\
13 & 5 & 8 & 91\\
\end{bmatrix}
$$</body></html><p>I can subtract row 1 by 1/2 times row 0 and get:</p><html><header><script type="text/x-mathjax-config">MathJax.Hub.Config({jax: ["input/TeX","output/HTML-CSS"], tex2jax: {inlineMath: [['$$','$$']]} , "HTML-CSS": {linebreaks: {automatic: true}}});</script><script src='https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script></header><body>$$
\begin{bmatrix}
6 & 32 & 1 & 84\\
0 & 8 & -27 & -29\\
91 & 82 & 9 & 344\\
13 & 5 & 8 & 91\\
\end{bmatrix}
$$</body></html><p>And I can multiple row 0 by 1/6 and get</p><html><header><script type="text/x-mathjax-config">MathJax.Hub.Config({jax: ["input/TeX","output/HTML-CSS"], tex2jax: {inlineMath: [['$$','$$']]} , "HTML-CSS": {linebreaks: {automatic: true}}});</script><script src='https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script></header><body>$$
\begin{bmatrix}
1 & \frac{32}{6} & \frac{1}{6} & 14\\
0 & 8 & -27 & -29\\
91 & 82 & 9 & 344\\
13 & 5 & 8 & 91\\
\end{bmatrix}
$$</body></html><p>With these powers we have the following goal:</p><p>Reduce our matrix into row echelon form. This <em>basically</em> (not exact definition) amounts to getting our matrix into the following state: 1. Each row (starting from the left) has one or more 0's a 1 and then anything afterwards. These are called "leading 1's" 2. Each leading 1 has <em>only</em> 0's below it</p><p>Here is an example:</p><html><header><script type="text/x-mathjax-config">MathJax.Hub.Config({jax: ["input/TeX","output/HTML-CSS"], tex2jax: {inlineMath: [['$$','$$']]} , "HTML-CSS": {linebreaks: {automatic: true}}});</script><script src='https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script></header><body>$$
\begin{bmatrix}
1 & 8 & -27\\
0 & 1 & 9\\
0 & 0 & 1\\
\end{bmatrix}
$$</body></html><p>There is a more persice and correct definition to row-echelon form, I suggest looking it up in the textbook (pg. 11)</p><h2>Programming Gaussian Elimination</h2><h3>The algorithm</h3><p>Alright enough math (even though we love it, writing it in latex is still time consuming :p ), let's get into the code.</p><p>The general algorithm for running Gaussian Elimination is to do the following:</p><ol><li>Find the leftmost column, c, which is not only filled with 0's</li><li>If the value in the top row is 0 swap the top row with a row whose value in that column is not 0.</li><li>Now let's say the value in the row 0, column c is k. Multiply row 0 by 1/k</li><li>Since k * (1/k) = 1 we now have our leading 1. If the value in row 1 below our leading 1 is v, subtract row 1 by v * row 0. This will cause the value below our leading 1 to become 0, which is exactly what we want.</li><li>Repeat this process by covering row 0 and pretending row 1 is not the top most row.</li></ol><p>I won't show an example here since once we get to programming we'll be able to run through many examples.</p><h3>Outline</h3><p>I think breaking these steps into there own methods (functions) is a good approach here. We can have:</p><ol><li>Locate leftmost ( not all 0's ) column</li><li>Find row with none 0's value</li><li>Swap rows</li><li>Multiply row by value</li><li>Subtract row by row</li></ol><h3>Locate Left Most Column</h3><p>At first I felt the title line for this method should be:</p><pre><code><div class="highlight"><span></span><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span> <span class="n">_LocateLeftMostNoneZeroColumn</span><span class="p">()</span>
</div></code></pre><p>Now I realize that after the first iteration of our Gaussian Elimination algorithm we will end up with a column with a single 1 and 0's below it but that if we called this method again, it would return the same column back to us. We need a way of telling this method not to consider certain columns. For now I think we can use a single integer to specify which row/column to start with. Now our title line is:</p><pre><code><div class="highlight"><span></span><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span> <span class="n">_LocateLeftMostNoneZeroColumn</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span> <span class="kt">uint32_t</span><span class="o">&gt;</span>  <span class="o">&amp;</span><span class="n">start</span><span class="p">)</span>
</div></code></pre><p>I am using <code>std::optional</code> here in case there does not exist a left most none zero column. In such a case we will return a nil optional.</p><p>The body of this method should be fairly straight forward. We loop over the matrix column by column checking if we can find one with a none 0 row value. Once we find one, return that column.</p><pre><code><div class="highlight"><span></span><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span> <span class="n">_LocateLeftMostNoneZeroColumn</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span> <span class="kt">uint32_t</span><span class="o">&gt;</span>  <span class="o">&amp;</span><span class="n">start</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="k">auto</span> <span class="p">[</span><span class="n">start_row</span><span class="p">,</span> <span class="n">start_col</span><span class="p">]</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">c</span> <span class="o">=</span> <span class="n">start_col</span><span class="p">;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">NumCols</span><span class="p">;</span> <span class="n">c</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">r</span> <span class="o">=</span> <span class="n">start_row</span><span class="p">;</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">NumRows</span><span class="p">;</span> <span class="n">r</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">matrix_</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="n">c</span><span class="p">;</span> 
            <span class="p">}</span>
        <span class="p">}</span> 
    <span class="p">}</span>
    <span class="k">return</span> <span class="p">{};</span>
<span class="p">}</span>
</div></code></pre><h3>Locate Row With None 0 Value</h3><p>Turns out that we already did this work in the previous step, though we did't make use of it. We only returned the column previously but now I am thinking we can return a pair (column, row). Let's modify our title line and function body.</p><pre><code><div class="highlight"><span></span><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span> <span class="kt">uint32_t</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">_LocateNextLeadingOnePosition</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span> <span class="kt">uint32_t</span><span class="o">&gt;</span>  <span class="o">&amp;</span><span class="n">start</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="k">auto</span> <span class="p">[</span><span class="n">start_row</span><span class="p">,</span> <span class="n">start_col</span><span class="p">]</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">c</span> <span class="o">=</span> <span class="n">start_col</span><span class="p">;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">NumCols</span><span class="p">;</span> <span class="n">c</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">r</span> <span class="o">=</span> <span class="n">start_row</span><span class="p">;</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">NumRows</span><span class="p">;</span> <span class="n">r</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">matrix_</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span> 
    <span class="p">}</span>
    <span class="k">return</span> <span class="p">{};</span>
<span class="p">}</span>
</div></code></pre><p>That's better. Killed two steps with 1 function change (as they say).</p><h3>Swap Rows</h3><p>This one is going to require its own function. On the bright side, cpp <code>std::vector</code> comes with a fancy <code>vectorA.swap(vectorB)</code> method (found <a href="https://www.cplusplus.com/reference/vector/vector/swap/">here</a>).</p><p>I think this seems cool, let's use that one.</p><pre><code><div class="highlight"><span></span><span class="kt">void</span> <span class="nf">_SwapRows</span><span class="p">(</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="o">&amp;</span><span class="n">row1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">uint32_t</span> <span class="o">&amp;</span><span class="n">row2</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">matrix_</span><span class="p">[</span><span class="n">row1</span><span class="p">].</span><span class="n">swap</span><span class="p">(</span><span class="n">matrix_</span><span class="p">[</span><span class="n">row2</span><span class="p">]);</span>
<span class="p">}</span>
</div></code></pre><p>The cpp reference website says time complexity for this swap is constant time. Love to see that.</p><h3>Multiply Row by Value</h3><p>This function also seems pretty straight forward. We'll take some value k as an argument and multiply each value in our row by k.</p><pre><code><div class="highlight"><span></span><span class="kt">void</span> <span class="nf">_ScaleRowBy</span><span class="p">(</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="o">&amp;</span><span class="n">row</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="nl">elm</span> <span class="p">:</span> <span class="n">matrix_</span><span class="p">[</span><span class="n">row</span><span class="p">])</span> <span class="p">{</span>
        <span class="n">elm</span> <span class="o">*=</span> <span class="n">k</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</div></code></pre><p>Here <code>elm</code> is a reference to the value in our row. That is why modifying <code>elm</code> modifies the value in our row.</p><p>This function, as it stands, will help for scaling a row by a value. On the other hand, this function fails to solve the Guassian Elimination step which subtracts one row by the scaled version of another. This is because when we want to subtract row A but k * row B, we <strong>don't</strong> want to actually modify row B.</p><p>We deal with this in the next section.</p><h3>Modifying Row A by Another Row</h3><p>I think the idea of modifying a row can occur in different scenarios and therefore making this type of function more generic would be a good idea. I am going to paste my thought below and then go over it:</p><pre><code><div class="highlight"><span></span><span class="kt">void</span> <span class="nf">_ModifyRowBy</span><span class="p">(</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="o">&amp;</span><span class="n">row</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="p">(</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="o">&amp;</span><span class="n">col</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">row_value</span><span class="p">)</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">modifier</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="nl">elm</span> <span class="p">:</span> <span class="n">matrix_</span><span class="p">[</span><span class="n">row</span><span class="p">])</span> <span class="p">{</span>
        <span class="n">elm</span> <span class="o">=</span> <span class="n">modifier</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">elm</span><span class="p">);</span>
        <span class="n">col</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</div></code></pre><p>Alright let's break down the title line. We request that the caller pass in the row they want to modify (first argument) and a function (second argument) which given a column number and a value returns a new value.</p><p>We can then take that new value, and set our rows value to that new value.</p><p>Let's take a look at using our <code>_ModifyRowBy</code> function to perform our "Multiply Row by Value" function.</p><p>Previously our "Multiply Row by Value" function was:</p><pre><code><div class="highlight"><span></span><span class="kt">void</span> <span class="nf">_ScaleRowBy</span><span class="p">(</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="o">&amp;</span><span class="n">row</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="nl">elm</span> <span class="p">:</span> <span class="n">matrix_</span><span class="p">[</span><span class="n">row</span><span class="p">])</span> <span class="p">{</span>
        <span class="n">elm</span> <span class="o">*=</span> <span class="n">k</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</div></code></pre><p>Now it becomes:</p><pre><code><div class="highlight"><span></span><span class="kt">void</span> <span class="nf">_ScaleRowBy</span><span class="p">(</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="o">&amp;</span><span class="n">row</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">_ModifyRowBy</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="p">[</span><span class="o">&amp;</span><span class="n">k</span><span class="p">](</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="o">&amp;</span><span class="n">col</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">old_value</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">old_value</span> <span class="o">*</span> <span class="n">k</span><span class="p">;</span>
    <span class="p">};</span>
<span class="p">}</span>
</div></code></pre><p>No real difference in size, but our new <code>_ModifyRowBy</code> function now allows us to write our "Subtract row by a multiple of another row" function as follows:</p><pre><code><div class="highlight"><span></span><span class="kt">void</span> <span class="nf">_SubtractRowByRowMultiple</span><span class="p">(</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="o">&amp;</span><span class="n">row_to_modify</span><span class="p">,</span> <span class="k">const</span> <span class="kt">uint32_t</span> <span class="o">&amp;</span><span class="n">other_row</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">_ModifyRowBy</span><span class="p">(</span><span class="n">row_to_modify</span><span class="p">,</span> <span class="p">[</span><span class="k">this</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">other_row</span><span class="p">](</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="o">&amp;</span><span class="n">col</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">old_value</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">old_value</span> <span class="o">-</span> <span class="p">(</span><span class="n">matrix_</span><span class="p">[</span><span class="n">other_row</span><span class="p">][</span><span class="n">col</span><span class="p">]</span> <span class="o">*</span> <span class="n">k</span><span class="p">);</span>
    <span class="p">});</span>
<span class="p">}</span>
</div></code></pre><p>Here we tell <code>_ModifyRowBy</code> we want to modify <code>row_to_modify</code>. We then have to capture, <code>this</code>, <code>k</code>, <code>other_row</code> because we want to use them inside our lambda function (between the curly braces).</p><blockquote><p>Note that even though <code>this</code> isnt used explicitly in our lambda, we need it for <code>matrix_</code> since that variable is really <code>this-&gt;matrix_</code>.</p></blockquote><p>Then given some row value <code>old_value</code> we want to subtract <code>k * matrix_[other_row][col]</code> (k times our other row's value).</p><p>With this complete we should be able to chain these functions together and reduce our matrix. Let's hook these functions together and update our <code>main.cpp</code>.</p><h3>Row Echelon Form</h3><p>Our Row echelon form function will be <code>public</code> and look as follows:</p><pre><code><div class="highlight"><span></span><span class="kt">void</span> <span class="nf">ReduceToRowEchelonForm</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
             <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="n">NumRows</span> <span class="o">&amp;&amp;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">NumCols</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="n">leading_1_pos</span> <span class="o">=</span> <span class="n">_LocateNextLeadingOnePosition</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">));</span>

        <span class="c1">// Check if our optional has a value</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">leading_1_pos</span><span class="p">.</span><span class="n">has_value</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// Get values our of our optional</span>
        <span class="k">const</span> <span class="k">auto</span><span class="p">[</span><span class="n">leading_1_row</span><span class="p">,</span> <span class="n">leading_1_col</span><span class="p">]</span> <span class="o">=</span> <span class="n">leading_1_pos</span><span class="p">.</span><span class="n">value</span><span class="p">();</span>

        <span class="c1">// Check if we should swap rows</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">leading_1_row</span> <span class="o">!=</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span> 
            <span class="n">_SwapRows</span><span class="p">(</span><span class="n">leading_1_row</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">// Produce leading 1</span>
        <span class="n">_ScaleRowBy</span><span class="p">(</span><span class="n">leading_1_row</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">matrix_</span><span class="p">[</span><span class="n">leading_1_row</span><span class="p">][</span><span class="n">leading_1_col</span><span class="p">]);</span>
        
        <span class="c1">// Zero out all values below leading 1</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">below_row</span> <span class="o">=</span> <span class="n">leading_1_row</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">below_row</span> <span class="o">&lt;</span> <span class="n">NumRows</span><span class="p">;</span> <span class="n">below_row</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">_SubtractRowByRowMultiple</span><span class="p">(</span><span class="n">below_row</span><span class="p">,</span> <span class="n">leading_1_row</span><span class="p">,</span> <span class="n">matrix_</span><span class="p">[</span><span class="n">below_row</span><span class="p">][</span><span class="n">leading_1_col</span><span class="p">]);</span>
        <span class="p">}</span>

        <span class="n">r</span> <span class="o">=</span> <span class="p">(</span><span class="n">leading_1_row</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">leading_1_col</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</div></code></pre><p>and our <code>main.cpp</code> will be updated to the following:</p><pre><code><div class="highlight"><span></span><span class="cp">#include</span> <span class="cpf">&quot;linalg/matrix.h&quot;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">mathlib</span><span class="o">::</span><span class="n">linalg</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="o">&gt;</span> <span class="n">matrix</span><span class="p">;</span>
    <span class="n">matrix</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">,</span>   <span class="mi">83</span><span class="p">,</span>  <span class="mi">33</span><span class="p">,</span>  <span class="mi">931</span><span class="p">,</span>  <span class="mi">11</span><span class="p">,</span>
              <span class="mi">65</span><span class="p">,</span>  <span class="o">-</span><span class="mi">12</span><span class="p">,</span>   <span class="mi">3</span><span class="p">,</span>   <span class="mi">99</span><span class="p">,</span>   <span class="mi">9</span><span class="p">,</span>
              <span class="mi">81</span><span class="p">,</span>    <span class="mi">5</span><span class="p">,</span> <span class="mi">653</span><span class="p">,</span> <span class="o">-</span><span class="mi">125</span><span class="p">,</span> <span class="mi">271</span><span class="p">,</span>
              <span class="mi">144</span><span class="p">,</span>  <span class="mi">32</span><span class="p">,</span>  <span class="mi">77</span><span class="p">,</span>  <span class="o">-</span><span class="mi">30</span><span class="p">,</span> <span class="o">-</span><span class="mi">15</span><span class="p">,</span>
              <span class="mi">10</span><span class="p">,</span>   <span class="mi">49</span><span class="p">,</span>  <span class="mi">95</span><span class="p">,</span>   <span class="mi">61</span><span class="p">,</span>  <span class="o">-</span><span class="mi">9</span><span class="p">;</span>
              
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;---------------Matrix---------------&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">matrix</span><span class="p">.</span><span class="n">Print</span><span class="p">();</span>
    <span class="n">matrix</span><span class="p">.</span><span class="n">ReduceToRowEchelonForm</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;-------- Row Echelon Form ----------&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">matrix</span><span class="p">.</span><span class="n">Print</span><span class="p">();</span>
<span class="p">}</span>
</div></code></pre><p>Let's give this a whirl!</p><p>Output ( in latex form ):</p><html><header><script type="text/x-mathjax-config">MathJax.Hub.Config({jax: ["input/TeX","output/HTML-CSS"], tex2jax: {inlineMath: [['$$','$$']]} , "HTML-CSS": {linebreaks: {automatic: true}}});</script><script src='https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script></header><body>$$
\begin{bmatrix}
10 & 83 & 33 & 931 & 11\\
65 & -12 & 3 & 99 & 9\\
81 & 5 & 653 & -125 & 271\\
144 & 32 & 77 & -30 & -15\\
10 & 49 & 95 & 61 & -9\\
\end{bmatrix}
$$
$$
\begin{bmatrix}
1 & 0 & 33 & 931 & 11\\
0 & 0 & 1 & 33 & 3\\
-0 & -0 & -0 & 1 & 0.0778813\\
-0 & -0 & -0 & -0 & 1\\
0 & 0 & 0 & 0 & 0\\
\end{bmatrix}
$$</body></html><p>Heyyy! Exactly what we hoped for (minus the minus signs before the 0's)!</p><p>Alright, I think this is a good place to stop for today. Today we implemented Guassian Elimination in our Matrix class. Next up is Gauss-Jordan Elimination. That is only a minor modifcation to Guassian Elimination so hopefully we breeze through that!</p><p>Until then,</p><p>-- Ehud</p></div><span>Tagged with: </span><ul class="tag-list"><li><a href="/tags/article">article</a></li><li><a href="/tags/linear-algebra">linear algebra</a></li><li><a href="/tags/math">math</a></li><li><a href="/tags/cpp">cpp</a></li><li><a href="/tags/matrix">matrix</a></li></ul></article></div><footer><p>Generated using <a href="https://github.com/johnsundell/publish">Publish</a></p><p><a href="/feed.rss">RSS feed</a></p></footer></body></html>