<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="og:site_name" content="Ramble Ramble"/><link rel="canonical" href="blog.ehudadler.com/linear/matrix"/><meta name="twitter:url" content="blog.ehudadler.com/linear/matrix"/><meta name="og:url" content="blog.ehudadler.com/linear/matrix"/><title>1.1 System of Equation and Matricies | Ramble Ramble</title><meta name="twitter:title" content="1.1 System of Equation and Matricies | Ramble Ramble"/><meta name="og:title" content="1.1 System of Equation and Matricies | Ramble Ramble"/><meta name="description" content="Building the start of a matrix class."/><meta name="twitter:description" content="Building the start of a matrix class."/><meta name="og:description" content="Building the start of a matrix class."/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/styles.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/favicon.png" type="image/png"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to Ramble Ramble"/></head><body class="item-page"><header><div class="wrapper"><a class="site-name" href="/">Ramble Ramble</a><p>Learning everyday</p><nav><ul><li><a href="/general">General</a></li><li><a class="selected" href="/linear">Linear Algebra</a></li><li><a href="/interview">Interview Questions</a></li><li><a href="/bigdata">Algorithms for Big Data</a></li><li><a href="/finance">Finance and Economics</a></li><li><a href="/swiftCompiler">Swiftcompiler</a></li></ul></nav></div></header><div class="wrapper"><article><div class="content"><p>Alrighty. So here we are. The format I was thinking of going with is: Reading through: <a href="https://www.amazon.com/Elementary-Linear-Algebra-Howard-Anton/dp/0470458216/ref=sr_1_3?dchild=1&keywords=howard+anton&qid=1606782925&sr=8-3">Howard Anton's Elementary Linear Algebra 7th Edition</a> and extending my <code>cpp</code> library as I learn new things.</p><h1>1.1 System of Equation and Matricies</h1><p>In this chapter most of the writing seems to be focused on explaining how systems of equations can be represented as a Matrix. So, here I am going to focus on the Matrix side of things and start our first class. The Matrix class.</p><h2>The Matrix class ( Outline )</h2><p>I want to plan out a bit how this Matrix class will look. In cpp we have the power of non-type template parameters. This means we can pass values (like constants!) into templates rather than types.</p><p>This seems to be the classic convention (see <a href="https://eigen.tuxfamily.org/dox/group__TutorialMatrixClass.html">Eigen</a>) and allows for compile time checks. These compile time checks are actually pretty cool in my opinion. We know (from reading!) that to multiply matricies A &amp; B together, Matrix A must have the <em>exact</em> same number of rows as Matrix B has columns. Since we can pass values (the number of rows and columns) of our matricies in at compile time, we can enforce these constraints then (at compile time) rather than at runtime!</p><p>I also really like how Eigen provides the option to initialize matricies as follows:</p><pre><code><div class="highlight"><span></span><span class="n">Matrix3x3</span> <span class="n">mat</span><span class="p">;</span>
<span class="n">mat</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span>
       <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span>
       <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">;</span>
</div></code></pre><p>So let's try to throw that into our class as well. Well call that "comma initialization" (sounds cool).</p><p>So know how we want to initialize our class, we know how we want to define its size and value type. Time to choose how we want to store the data inside it.</p><p>I had given some thought to storing the values in a single array. Something like:</p><pre><code><div class="highlight"><span></span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">]</span>
</div></code></pre><p>Rather than the classical 2d:</p><pre><code><div class="highlight"><span></span><span class="p">[</span>
    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">]</span>
<span class="p">]</span>
</div></code></pre><p>I think given a row, and column <code>(r, c)</code> getting a value is basically as easy in both cases.</p><p>Keeping with the classic (2d array) seems like the best approach and most straight forward. In <code>swift</code> there is a good reason for going the single array route (Wanting to use <code>ublas/cblas</code> in <code>Accelerate</code>) but the purpose of this class isn't for <code>cpp</code> as much as allowing us to implement some linear algebra so let's go with with the 2d approach.</p><p>I'll use <code>std::vector</code> as my array and create a type-alias so I don't have to continously type the arduous <code>std::vector&lt;std::vector....&gt;</code> each and every time.</p><blockquote><p>Digression: Halfway through this post and I can tell this blog will be teaching me how to spell better.</p></blockquote><p>Anyways, our type-alias will look like this:</p><pre><code><div class="highlight"><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">K</span><span class="o">&gt;</span>
<span class="k">using</span> <span class="n">Dataframe</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">K</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">;</span>
</div></code></pre><p>I'm calling this 2d vector a "Dataframe". I feel like a Dataframe is a more relaxed Matrix. It can take any type of value and it doesn't have any special methods you can call on it. I guess I think of it as the data structure behind a Matrix (??? does that make sense ???).</p><blockquote><p>We use <code>using</code> here rather than <code>typedef</code> because <code>typedef</code> does not work with <code>template</code> parameters.</p></blockquote><p>That is all that we need for section 1.1. Let's begin</p><h2>The Matrix class</h2><h3>Start</h3><p>First off is defining the class. We want the rows, columns, and type being stored to be passed in at compile time via non-type template arguments so lets start there.</p><p>Our template will look something like:</p><pre><code><div class="highlight"><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Type</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">NumRows</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">NumCols</span> <span class="o">=</span> <span class="mi">0</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Matrix</span> <span class="p">{};</span>
</div></code></pre><p>Here we've defined our template to take 3 parameters. The first of the three is the type which the matrix will hold, the second is the number of rows our matrix should have, and the last is the number of columns.</p><p>At the moment (and this is unlikely the change) our matrix will be filled stricly with numeric values. We shouldn't allow the user to pass in <code>std::string</code> or some other types.</p><p>Additionally, we want this check to happen at compile time again. To enable this we will use <code>static_assert</code> to run a check at compile time on the passed in type (<code>Type</code>), verifying that it in indeed a numeric value.</p><p>More specifically, we want the type to be either an integral value (<code>short</code>, <code>int</code>, <code>long</code>, <code>long long</code>..etc) or a floating-point value (<code>float</code>, <code>double</code>...).</p><p>Fortunately for us, <code>cpp</code> has a built in check: <a href="https://en.cppreference.com/w/cpp/types/is_arithmetic">std:: is_arithmetic</a>, which is exactly what we are looking for.</p><p>We end up with something like this,</p><pre><code><div class="highlight"><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Type</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">NumRows</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">NumCols</span> <span class="o">=</span> <span class="mi">0</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Matrix</span> <span class="p">{</span>
    <span class="k">static_assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_arithmetic</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span>
                  <span class="s">&quot;Matrix value must have an integral or floating point type&quot;</span><span class="p">);</span>
<span class="p">};</span> <span class="c1">// Matrix</span>
</div></code></pre><p>This is looking good!</p><p>Let's add in our <code>Dataframe</code> type-alias, and create our instance variable:</p><pre><code><div class="highlight"><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Type</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">NumRows</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">NumCols</span> <span class="o">=</span> <span class="mi">0</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Matrix</span> <span class="p">{</span>

    <span class="c1">// Make sure that the templated `Type` parameter is valid</span>
    <span class="k">static_assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_arithmetic</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span>
                  <span class="s">&quot;Matrix value must have an integral or floating point type&quot;</span><span class="p">);</span>
                  
<span class="k">public</span><span class="o">:</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">K</span><span class="o">&gt;</span>
    <span class="k">using</span> <span class="n">Dataframe</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">K</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">;</span>
    
<span class="k">private</span><span class="o">:</span>    
    <span class="n">Dataframe</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span> <span class="n">matrix_</span><span class="p">;</span>
<span class="p">};</span> <span class="c1">// Matrix</span>
</div></code></pre><p>Since we already know (at compile time) the number of rows and columns, we might as well initialize our <code>matrix_</code> instance variable now.</p><pre><code><div class="highlight"><span></span><span class="c1">// Matrix Class</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Type</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">NumRows</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">NumCols</span> <span class="o">=</span> <span class="mi">0</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Matrix</span> <span class="p">{</span>

    <span class="c1">// Make sure that the templated `Type` parameter is valid</span>
    <span class="k">static_assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_arithmetic</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span>
                  <span class="s">&quot;Matrix value must have an integral or floating point type&quot;</span><span class="p">);</span>
                  
<span class="k">public</span><span class="o">:</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">K</span><span class="o">&gt;</span>
    <span class="k">using</span> <span class="n">Dataframe</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">K</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">;</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">Dataframe</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span> <span class="n">matrix_</span> <span class="o">=</span> <span class="n">Dataframe</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span><span class="p">(</span><span class="n">NumRows</span><span class="p">,</span>
                                           <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span><span class="p">(</span><span class="n">NumCols</span><span class="p">));</span>
<span class="p">};</span> <span class="c1">// Matrix</span>
</div></code></pre><p>Awesome. As narcissistic as I am, it's always good to test to make sure the code you wrote runs. Let's add in some <code>#inlcude</code> and build a <code>main.cpp</code>.</p><pre><code><div class="highlight"><span></span><span class="c1">// Main.cpp</span>

<span class="cp">#include</span> <span class="cpf">&quot;linalg/matrix.h&quot; // Import out lib</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">mathlib</span><span class="o">::</span><span class="n">linalg</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>    <span class="mi">1</span><span class="o">&gt;</span> <span class="n">matrix</span><span class="p">;</span>
                         <span class="c1">// Type   Rows  Cols</span>
<span class="p">}</span>
</div></code></pre><p>Works!</p><p>As hoped, building with:</p><pre><code><div class="highlight"><span></span><span class="c1">// Main.cpp</span>

<span class="cp">#include</span> <span class="cpf">&quot;linalg/matrix.h&quot; // Import out lib</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">mathlib</span><span class="o">::</span><span class="n">linalg</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>    <span class="mi">1</span><span class="o">&gt;</span> <span class="n">matrix</span><span class="p">;</span>
                               <span class="c1">// Type   Rows  Cols</span>
<span class="p">}</span>
</div></code></pre><p>fails with,</p><blockquote><p><code></code><code>error: static_assert failed due to requirement 'std::is_arithmetic&lt;std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; &gt;::value' "Matrix value must have an  integral or floating point type" static_assert(std::is_arithmetic&lt;Type&gt;::value,</code><code></code></p></blockquote><h2>Comma Init</h2><p>Time to initialize. Building the comma init. is 100% unnecessary, but fun. So...</p><p>The idea is as follows:</p><ol><li>We want to overload the <code>&lt;&lt;</code> operator so that when its called on our Matrix class, it returns a new class called CommaInit.</li><li>The CommaInit class has an overloaded <code>,</code> operator which:<ol start="3"><li>Adds the next value to our Matrix</li><li>Returns itself (CommaInit) to pick up the next <code>,</code> (if one exists))</li></ol></li></ol><p>This may seem compilicated, so let's dive into the code side of things and walk through it.</p><h3>Overload <code>&lt;&lt;</code></h3><p>Overloading functions is common in many languages. In <code>cpp</code> we can overload the <code>&lt;&lt;</code> by adding the following into our class:</p><pre><code><div class="highlight"><span></span><span class="n">CommaInit</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">Type</span> <span class="n">v</span><span class="p">)</span> <span class="p">{}</span>
</div></code></pre><p>We have yet to write our <code>CommaInit</code> class but we already know we want our <code>&lt;&lt;</code> overload to return that class type. Additionally we want to kick off this initialization when the type on the right side of the <code>&lt;&lt;</code> matches the type we are storing in our Matrix.</p><p>Recall our goal:</p><pre><code><div class="highlight"><span></span><span class="n">Matrix3x3</span> <span class="n">mat</span><span class="p">;</span>
<span class="n">mat</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span>
       <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span>
       <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">;</span>
</div></code></pre><p>I will put into parenthesis where our operator is taking place:</p><pre><code><div class="highlight"><span></span><span class="p">(</span><span class="n">mat</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span>
         <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span>
         <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">;</span>
</div></code></pre><p>After this operator occurs we will have:</p><pre><code><div class="highlight"><span></span><span class="n">commaInit</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span>
        <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span>
        <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">;</span>
</div></code></pre><p>which is exactly what we want. Now the <code>commaInit</code> object is next to a comma which will kick off that part of the sequence.</p><p>Before getting ahead of ourselves let's finish implementing the overload.</p><p>Notice how the first value (the <code>1</code>) is gone after the overloaded function finishes. This means we need to place that value into our matrix before the overloaded function ends.</p><pre><code><div class="highlight"><span></span><span class="n">CommaInit</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">Type</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
<span class="p">}</span>
</div></code></pre><p>Now we must create the <code>CommaInit</code> object and return it. One thing we know is that at this point the <code>CommaInit</code> class is about to take over and we still somehow need a way of altering the <code>matrix_</code>. To achieve this we will pass the address og our <code>matrix_</code> into the <code>CommaInit</code> constructor. This will allow <code>CommaInit</code> to mutate our <code>matrix_</code>.</p><pre><code><div class="highlight"><span></span><span class="n">CommaInit</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">Type</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">matrix_</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
    <span class="k">return</span> <span class="nf">CommaInit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">matrix_</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> 
    <span class="c1">// The 1 here denotes that we are upto the 1th index of our matrix.</span>
    <span class="c1">// We already ingested the 0th index on the line before.</span>
<span class="p">}</span>
</div></code></pre><p>All that is left is to create the <code>CommaInit</code> class. I wont walk through this part exactly but the class is small and hopefully understandable:</p><pre><code><div class="highlight"><span></span><span class="k">struct</span> <span class="n">CommaInit</span> <span class="p">{</span>
    <span class="n">Dataframe</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">df</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">index</span><span class="p">;</span>
    <span class="n">CommaInit</span><span class="p">(</span><span class="n">Dataframe</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">df</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">index</span><span class="p">)</span> 
    <span class="o">:</span> <span class="n">df</span><span class="p">(</span><span class="n">df</span><span class="p">),</span> <span class="n">index</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="p">{};</span>
    
    <span class="c1">// Overload the , operator</span>
    <span class="n">CommaInit</span> <span class="k">operator</span><span class="p">,(</span><span class="n">Type</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">(</span><span class="o">*</span><span class="n">df</span><span class="p">)[</span><span class="n">index</span> <span class="o">/</span> <span class="n">NumCols</span><span class="p">][</span><span class="n">index</span> <span class="o">%</span> <span class="n">NumCols</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
        <span class="k">return</span> <span class="nf">CommaInit</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// Recursion-like</span>
    <span class="p">}</span>
<span class="p">};</span>
</div></code></pre><p>Let's add this to our Matrix class and try updating our <code>main.cpp</code></p><pre><code><div class="highlight"><span></span><span class="c1">// Matrix Class</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Type</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">NumRows</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">NumCols</span> <span class="o">=</span> <span class="mi">0</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Matrix</span> <span class="p">{</span>

    <span class="c1">// Make sure that the templated `Type` parameter is valid</span>
    <span class="k">static_assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_arithmetic</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span>
                  <span class="s">&quot;Matrix value must have an integral or floating point type&quot;</span><span class="p">);</span>
                  
<span class="k">public</span><span class="o">:</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">K</span><span class="o">&gt;</span>
    <span class="k">using</span> <span class="n">Dataframe</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">K</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">;</span>

    <span class="k">struct</span> <span class="n">CommaInit</span> <span class="p">{</span>
        <span class="n">Dataframe</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">df</span><span class="p">;</span>
        <span class="kt">uint32_t</span> <span class="n">index</span><span class="p">;</span>
        <span class="n">CommaInit</span><span class="p">(</span><span class="n">Dataframe</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">df</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">index</span><span class="p">)</span> 
        <span class="o">:</span> <span class="n">df</span><span class="p">(</span><span class="n">df</span><span class="p">),</span> <span class="n">index</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="p">{};</span>
        
        <span class="c1">// Overload the , operator</span>
        <span class="n">CommaInit</span> <span class="k">operator</span><span class="p">,(</span><span class="n">Type</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
            <span class="p">(</span><span class="o">*</span><span class="n">df</span><span class="p">)[</span><span class="n">index</span> <span class="o">/</span> <span class="n">NumCols</span><span class="p">][</span><span class="n">index</span> <span class="o">%</span> <span class="n">NumCols</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
            <span class="k">return</span> <span class="nf">CommaInit</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// Recursion-like</span>
        <span class="p">}</span>
    <span class="p">};</span>
    <span class="c1">// Everything here will be public</span>
    <span class="n">CommaInit</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">Type</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">matrix_</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
        <span class="k">return</span> <span class="nf">CommaInit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">matrix_</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> 
        <span class="c1">// The 1 here denotes that we are upto the 1th index of our matrix.</span>
        <span class="c1">// We already ingested the 0th index on the line before.</span>
    <span class="p">}</span>
<span class="k">private</span><span class="o">:</span>    
    <span class="n">Dataframe</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span> <span class="n">matrix_</span> <span class="o">=</span> <span class="n">Dataframe</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span><span class="p">(</span><span class="n">NumRows</span><span class="p">,</span>
                                           <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span><span class="p">(</span><span class="n">NumCols</span><span class="p">));</span>
<span class="p">};</span> <span class="c1">// Matrix</span>
</div></code></pre><pre><code><div class="highlight"><span></span><span class="c1">// main.cpp</span>
<span class="cp">#include</span> <span class="cpf">&quot;linalg/matrix.h&quot;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">mathlib</span><span class="o">::</span><span class="n">linalg</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="n">matrix</span>
    <span class="n">matrix</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</div></code></pre><p>Seems to work. Let's confirm by adding a <code>Print</code> function which prints our matrix. Again, I'll just show the function. Nothing special here.</p><pre><code><div class="highlight"><span></span><span class="kt">void</span> <span class="nf">Print</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NumRows</span> <span class="o">*</span> <span class="n">NumCols</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">matrix_</span><span class="p">[</span><span class="n">i</span> <span class="o">/</span> <span class="n">NumCols</span><span class="p">][</span><span class="n">i</span> <span class="o">%</span> <span class="n">NumCols</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">NumCols</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</div></code></pre><p>We get,</p><pre><code><div class="highlight"><span></span><span class="c1">// Matrix Class</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Type</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">NumRows</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">NumCols</span> <span class="o">=</span> <span class="mi">0</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Matrix</span> <span class="p">{</span>

    <span class="c1">// Make sure that the templated `Type` parameter is valid</span>
    <span class="k">static_assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_arithmetic</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span>
                  <span class="s">&quot;Matrix value must have an integral or floating point type&quot;</span><span class="p">);</span>
                  
<span class="k">public</span><span class="o">:</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">K</span><span class="o">&gt;</span>
    <span class="k">using</span> <span class="n">Dataframe</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">K</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">;</span>

    <span class="p">...</span> <span class="n">See</span> <span class="n">above</span> <span class="k">for</span> <span class="n">other</span> <span class="n">code</span>
    
    <span class="kt">void</span> <span class="n">Print</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NumRows</span> <span class="o">*</span> <span class="n">NumCols</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">matrix_</span><span class="p">[</span><span class="n">i</span> <span class="o">/</span> <span class="n">NumCols</span><span class="p">][</span><span class="n">i</span> <span class="o">%</span> <span class="n">NumCols</span><span class="p">];</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">NumCols</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="k">private</span><span class="o">:</span>    
    <span class="n">Dataframe</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span> <span class="n">matrix_</span> <span class="o">=</span> <span class="n">Dataframe</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span><span class="p">(</span><span class="n">NumRows</span><span class="p">,</span>
                                           <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span><span class="p">(</span><span class="n">NumCols</span><span class="p">));</span>
<span class="p">};</span> <span class="c1">// Matrix</span>
</div></code></pre><pre><code><div class="highlight"><span></span><span class="c1">// main.cpp</span>

<span class="cp">#include</span> <span class="cpf">&quot;linalg/matrix.h&quot;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">mathlib</span><span class="o">::</span><span class="n">linalg</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">matrix</span><span class="p">;</span>
    <span class="n">matrix</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span>
              <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span>
              <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">;</span>
    <span class="n">matrix</span><span class="p">.</span><span class="n">Print</span><span class="p">();</span>
<span class="p">}</span>
</div></code></pre><p>Running this give:</p><pre><code><div class="highlight"><span></span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span>
<span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span>
<span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span>
</div></code></pre><p>Exactly what we hoped for.</p><p>It's getting late and I feel this was a good start at our matrix class. Section 1.2 deals with Gaussian Elimination so looks like that is our next step!</p><p>-- Ehud</p></div><span>Tagged with: </span><ul class="tag-list"><li><a href="/tags/article">article</a></li><li><a href="/tags/linear-algebra">linear algebra</a></li><li><a href="/tags/math">math</a></li><li><a href="/tags/cpp">cpp</a></li><li><a href="/tags/matrix">matrix</a></li></ul></article></div><footer><p>Generated using <a href="https://github.com/johnsundell/publish">Publish</a></p><p><a href="/feed.rss">RSS feed</a></p></footer></body></html>