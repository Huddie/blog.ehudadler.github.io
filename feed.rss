<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content"><channel><title>Ramble Ramble</title><description>Learning everyday</description><link>blog.ehudadler.com</link><language>en</language><lastBuildDate>Mon, 7 Dec 2020 08:41:16 -0500</lastBuildDate><pubDate>Mon, 7 Dec 2020 08:41:16 -0500</pubDate><ttl>250</ttl><atom:link href="blog.ehudadler.com/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">blog.ehudadler.com/linear/gauss-jordan</guid><title>1.2 Gauss-Jordan</title><description>Extending our matrix class to include gauss-jordan elimination.</description><link>blog.ehudadler.com/linear/gauss-jordan</link><pubDate>Thu, 3 Dec 2020 18:58:00 -0500</pubDate><content:encoded><![CDATA[<p>Welcome back. If you're here for the first time I suggest reading from the beginning of the series (<a href="https://blog.ehudadler.com/linear/matrix/">over here</a>).</p><h1>Recap</h1><p>Last time, which happens to be yesterday, we added gaussian elimination to our matrix class. On the way to doing this we also added a few other helper methods which we can hopefully use throughout this series.</p><h1>1.2 Gauss-Jordan Elimination</h1><p>Today we extend our gaussian elimination (albeit in a new function) to perform gauss-jordan elimination.</p><p>If you recall from last week, we said (not precisely) that gaussian elimination amounts to getting our matrix into the following form:</p><ol><li>Each row is either all zeros or contains a leading 1</li><li>Each leading 1 has only 0's below it</li></ol><p>Our final matrix from last time was:</p><html><header><script type="text/x-mathjax-config">MathJax.Hub.Config({jax: ["input/TeX","output/HTML-CSS"], tex2jax: {inlineMath: [['$$','$$']]} , "HTML-CSS": {linebreaks: {automatic: true}}});</script><script src='https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script></header><body>$$
\begin{bmatrix}
1 & 0 & 33 & 931 & 11\\
0 & 0 & 1 & 33 & 3\\
-0 & -0 & -0 & 1 & 0.0778813\\
-0 & -0 & -0 & -0 & 1\\
0 & 0 & 0 & 0 & 0\\
\end{bmatrix}
$$</body></html><p>We were pleased with our results, though we mentioned we'd like to clean up those negative 0's.</p><p>Gauss-Jordan elimination is the same as Gaussian Elimination but with 1 added rule: All leadings 1's must have <strong>only</strong> zeros below <em>and</em> above it.</p><p>Similar to last time we will start with going over the general algorithm</p><h2>Algorithm</h2><p>Step 1 in our algorithm will be performing Gaussian Elimination (this is an extension after all). At this point our matrix is in <em>row echelon form</em>.</p><p>Next we start from the last row and force each value above our leading 1 to be 0 just as we did when forcing all values below our leading 1 to be 0.</p><p>If the value we are trying to zero out is <code>k</code>, then we want to subtract that row by k times the row our leading 1 is in.</p><h2>Programming</h2><p>I feel like this is very similar to the last article. We can use our subtract <code>_SubtractRowByRowMultiple</code> method and just loop over the matrix bottom right to top left.</p><p>I'll just post the code here. I feel like it shares enough similarities with our Gaussian Elimination method that not much explaination is necessary.</p><p>I commented it to add clarity where I felt this code differed from Gaussian Elimination.</p><pre><code><div class="highlight"><span></span><span class="kt">void</span> <span class="nf">ReduceToReducedRowEchelonForm</span><span class="p">()</span> <span class="p">{</span>

    <span class="c1">// Reduce to row echelon form</span>
    <span class="n">ReduceToRowEchelonForm</span><span class="p">();</span>

    <span class="kt">int32_t</span> <span class="n">r</span> <span class="o">=</span> <span class="n">NumRows</span><span class="p">,</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">NumCols</span><span class="p">;</span>

    <span class="k">while</span><span class="p">(</span><span class="n">c</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

        <span class="c1">// Save the current row position in case this column is all 0&#39;s</span>
        <span class="kt">int32_t</span> <span class="n">temp_row</span> <span class="o">=</span> <span class="n">r</span><span class="p">;</span> 

        <span class="c1">// If r == 0 then no work to do so might as well </span>
        <span class="c1">// not consider this leading 1</span>
        <span class="k">for</span><span class="p">(;</span> <span class="n">r</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">r</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">matrix_</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
                    
        <span class="c1">// If we located a leading 1 in row 0 then there is</span>
        <span class="c1">// no work to be done. Just break out. We&#39;re finished</span>
       <span class="k">if</span><span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
           <span class="k">break</span><span class="p">;</span>
       <span class="p">}</span>

       <span class="c1">// No leading 1 found</span>
       <span class="k">if</span><span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
           <span class="n">r</span> <span class="o">=</span> <span class="n">temp_row</span><span class="p">;</span>
           <span class="n">c</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
           <span class="k">continue</span><span class="p">;</span>
       <span class="p">}</span>
        
        <span class="c1">// Zero out all values above leading 1</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int32_t</span> <span class="n">above_row</span> <span class="o">=</span> <span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">above_row</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">above_row</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">_SubtractRowByRowMultiple</span><span class="p">(</span><span class="n">above_row</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">matrix_</span><span class="p">[</span><span class="n">above_row</span><span class="p">][</span><span class="n">c</span><span class="p">]);</span>
        <span class="p">}</span>

        <span class="n">r</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">c</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</div></code></pre><p>This post is short since it's just an extension to last weeks. If we update our <code>main.cpp</code> to the following:</p><pre><code><div class="highlight"><span></span><span class="cp">#include</span> <span class="cpf">&quot;linalg/matrix.h&quot;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">mathlib</span><span class="o">::</span><span class="n">linalg</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="o">&gt;</span> <span class="n">matrix</span><span class="p">;</span>
    <span class="n">matrix</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>  <span class="mi">33</span><span class="p">,</span>  <span class="mi">931</span><span class="p">,</span>  <span class="mi">11</span><span class="p">,</span>
              <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>   <span class="mi">3</span><span class="p">,</span>   <span class="mi">99</span><span class="p">,</span>   <span class="mi">9</span><span class="p">,</span>
              <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span> <span class="mi">653</span><span class="p">,</span> <span class="o">-</span><span class="mi">125</span><span class="p">,</span> <span class="mi">271</span><span class="p">,</span>
              <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>  <span class="mi">77</span><span class="p">,</span>  <span class="o">-</span><span class="mi">30</span><span class="p">,</span> <span class="o">-</span><span class="mi">15</span><span class="p">,</span>
              <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>  <span class="mi">95</span><span class="p">,</span>   <span class="mi">61</span><span class="p">,</span>  <span class="o">-</span><span class="mi">9</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;---------------Matrix---------------&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">matrix</span><span class="p">.</span><span class="n">LatexPrint</span><span class="p">();</span>
    <span class="n">matrix</span><span class="p">.</span><span class="n">ReduceToRowEchelonForm</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;-------- Row Echelon Form ----------&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">matrix</span><span class="p">.</span><span class="n">LatexPrint</span><span class="p">();</span>
    <span class="n">matrix</span><span class="p">.</span><span class="n">ReduceToReducedRowEchelonForm</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;---- Reduced Row Echelon Form ------&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">matrix</span><span class="p">.</span><span class="n">LatexPrint</span><span class="p">();</span>
<span class="p">}</span>
</div></code></pre><p>we can return a get the output (In Latex):</p><html><header><script type="text/x-mathjax-config">MathJax.Hub.Config({jax: ["input/TeX","output/HTML-CSS"], tex2jax: {inlineMath: [['$$','$$']]} , "HTML-CSS": {linebreaks: {automatic: true}}});</script><script src='https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script></header><body>$$

\begin{bmatrix}
1 & 0 & 33 & 931 & 11\\
0 & 0 & 3 & 99 & 9\\
0 & 0 & 653 & -125 & 271\\
0 & 0 & 77 & -30 & -15\\
0 & 0 & 95 & 61 & -9
\end{bmatrix}
\ \
\begin{bmatrix}
1 & 0 & 33 & 931 & 11\\
0 & 0 & 1 & 33 & 3\\
0 & 0 & 0 & 1 & 0.0778813\\
0 & 0 & 0 & 0 & 1\\
0 & 0 & 0 & 0 & 0
\end{bmatrix}
\ \
\begin{bmatrix}
1 & 0 & 0 & 0 & 0\\
0 & 0 & 1 & 0 & 0\\
0 & 0 & 0 & 1 & 0\\
0 & 0 & 0 & 0 & 1\\
0 & 0 & 0 & 0 & 0\\
\end{bmatrix}

$$</body></html><p>Till next time!</p><p>-- Ehud</p>]]></content:encoded></item><item><guid isPermaLink="true">blog.ehudadler.com/linear/gaussian-elimination</guid><title>1.2 Gaussian Elimination</title><description>Adding gaussian elimination to our matrix class</description><link>blog.ehudadler.com/linear/gaussian-elimination</link><pubDate>Wed, 2 Dec 2020 18:58:00 -0500</pubDate><content:encoded><![CDATA[<p>Welcome back. If you're here for the first time I suggest reading from the beginning of the series (<a href="https://blog.ehudadler.com/linear/matrix/">over here</a>).</p><p>I also suggest reading all my blog posts though...</p><h1>Recap</h1><p>I feel like starting off each post in this series with a recap is a good idea.</p><p>Last time we outlined and built the beginning stages of our Matrix class. A matrix is a just a 2d grid filled with numbers. It's always weird recapping your work and remembering that it took like 3 hours to produce but 1 sentence to summarize. I guess what I'm saying is, that's the recap. Onto the main event.</p><h1>1.2 Gaussian Elimination</h1><p>I believe at the end of the last post (yup confirmed) I mentioned this post would deal with gaussian elimination. I've though about it a bit since then and am excited to give this a try.</p><h2>What is Gaussian Elimination?</h2><p>Let's say you're presented with the following problem on a test:</p><html><header><script type="text/x-mathjax-config">MathJax.Hub.Config({jax: ["input/TeX","output/HTML-CSS"], tex2jax: {inlineMath: [['$$','$$']]} , "HTML-CSS": {linebreaks: {automatic: true}}});</script><script src='https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script></header><body>$$
\begin{align}
3x + 8y &= 13\\
6x + 32y &= 84
\end{align}
$$</body></html><p>and asked to find what values you should set x and y to in order to make the equation evaluate to true.</p><p>You may start by inspecting the two equations and testing some values. More likely you will solve one equation (let's say the first one) so that one variable (x for example) is in terms of y. Something like:</p><html><header><script type="text/x-mathjax-config">MathJax.Hub.Config({jax: ["input/TeX","output/HTML-CSS"], tex2jax: {inlineMath: [['$$','$$']]} , "HTML-CSS": {linebreaks: {automatic: true}}});</script><script src='https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script></header><body>$$
\begin{align}
    3x + 8y &= 13 \\
    3x &= 8y + 13 \\
    x &= \frac{8y + 13}{3}
\end{align}
$$</body></html><p>Now you can replace x with</p><html><header><script type="text/x-mathjax-config">MathJax.Hub.Config({jax: ["input/TeX","output/HTML-CSS"], tex2jax: {inlineMath: [['$$','$$']]} , "HTML-CSS": {linebreaks: {automatic: true}}});</script><script src='https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script></header><body>$$
\frac{8y + 13}{3}
$$</body></html><p>and solve regularly. This approach works well when you have 2 equations and 2 unknowns, but what happens with the following:</p><html><header><script type="text/x-mathjax-config">MathJax.Hub.Config({jax: ["input/TeX","output/HTML-CSS"], tex2jax: {inlineMath: [['$$','$$']]} , "HTML-CSS": {linebreaks: {automatic: true}}});</script><script src='https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script></header><body>$$
\begin{align}
3x + 8y - 54z &= 13\\
6x + 32y + z &= 84\\
91x + 82y + 9z &= 344\\
13x + 5y + 8z &= 91\\
\end{align}
$$</body></html><p>Whether or not this has a solution (I have no clue) solving it via substitution is much harder.</p><p>Introducing Gaussian Elimination. Gaussian Elimination is one method for making progress on a problem like this.</p><h2>How Gaussian Elimination Works</h2><p>First off, Gaussian Elimination works on a Matrix. So given our system of equations</p><html><header><script type="text/x-mathjax-config">MathJax.Hub.Config({jax: ["input/TeX","output/HTML-CSS"], tex2jax: {inlineMath: [['$$','$$']]} , "HTML-CSS": {linebreaks: {automatic: true}}});</script><script src='https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script></header><body>$$
\begin{align}
3x + 8y - 54z &= 13\\
6x + 32y + z &= 84\\
91x + 82y + 9z &= 344\\
13x + 5y + 8z &= 91\\
\end{align}
$$</body></html><p>we must produce the matrix:</p><html><header><script type="text/x-mathjax-config">MathJax.Hub.Config({jax: ["input/TeX","output/HTML-CSS"], tex2jax: {inlineMath: [['$$','$$']]} , "HTML-CSS": {linebreaks: {automatic: true}}});</script><script src='https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script></header><body>$$
\begin{bmatrix}
3 & 8 & -54 & 13\\
6 & 32 & 1 & 84\\
91 & 82 & 9 & 344\\
13 & 5 & 8 & 91\\
\end{bmatrix}
$$</body></html><p>Now that we have our matrix, we can discuss the rules.</p><p>There are 3 valid moves you can make while performing Gaussian Elimination</p><ol><li>Swap 2 rows</li><li>Subtract one row by k times another row</li><li>Multiple through a row by k</li></ol><p>For example I can swap row 0 and row 1 and get:</p><html><header><script type="text/x-mathjax-config">MathJax.Hub.Config({jax: ["input/TeX","output/HTML-CSS"], tex2jax: {inlineMath: [['$$','$$']]} , "HTML-CSS": {linebreaks: {automatic: true}}});</script><script src='https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script></header><body>$$
\begin{bmatrix}
6 & 32 & 1 & 84\\
3 & 8 & -54 & 13\\
91 & 82 & 9 & 344\\
13 & 5 & 8 & 91\\
\end{bmatrix}
$$</body></html><p>I can subtract row 1 by 1/2 times row 0 and get:</p><html><header><script type="text/x-mathjax-config">MathJax.Hub.Config({jax: ["input/TeX","output/HTML-CSS"], tex2jax: {inlineMath: [['$$','$$']]} , "HTML-CSS": {linebreaks: {automatic: true}}});</script><script src='https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script></header><body>$$
\begin{bmatrix}
6 & 32 & 1 & 84\\
0 & 8 & -27 & -29\\
91 & 82 & 9 & 344\\
13 & 5 & 8 & 91\\
\end{bmatrix}
$$</body></html><p>And I can multiple row 0 by 1/6 and get</p><html><header><script type="text/x-mathjax-config">MathJax.Hub.Config({jax: ["input/TeX","output/HTML-CSS"], tex2jax: {inlineMath: [['$$','$$']]} , "HTML-CSS": {linebreaks: {automatic: true}}});</script><script src='https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script></header><body>$$
\begin{bmatrix}
1 & \frac{32}{6} & \frac{1}{6} & 14\\
0 & 8 & -27 & -29\\
91 & 82 & 9 & 344\\
13 & 5 & 8 & 91\\
\end{bmatrix}
$$</body></html><p>With these powers we have the following goal:</p><p>Reduce our matrix into row echelon form. This <em>basically</em> (not exact definition) amounts to getting our matrix into the following state: 1. Each row (starting from the left) has one or more 0's a 1 and then anything afterwards. These are called "leading 1's" 2. Each leading 1 has <em>only</em> 0's below it</p><p>Here is an example:</p><html><header><script type="text/x-mathjax-config">MathJax.Hub.Config({jax: ["input/TeX","output/HTML-CSS"], tex2jax: {inlineMath: [['$$','$$']]} , "HTML-CSS": {linebreaks: {automatic: true}}});</script><script src='https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script></header><body>$$
\begin{bmatrix}
1 & 8 & -27\\
0 & 1 & 9\\
0 & 0 & 1\\
\end{bmatrix}
$$</body></html><p>There is a more persice and correct definition to row-echelon form, I suggest looking it up in the textbook (pg. 11)</p><h2>Programming Gaussian Elimination</h2><h3>The algorithm</h3><p>Alright enough math (even though we love it, writing it in latex is still time consuming :p ), let's get into the code.</p><p>The general algorithm for running Gaussian Elimination is to do the following:</p><ol><li>Find the leftmost column, c, which is not only filled with 0's</li><li>If the value in the top row is 0 swap the top row with a row whose value in that column is not 0.</li><li>Now let's say the value in the row 0, column c is k. Multiply row 0 by 1/k</li><li>Since k * (1/k) = 1 we now have our leading 1. If the value in row 1 below our leading 1 is v, subtract row 1 by v * row 0. This will cause the value below our leading 1 to become 0, which is exactly what we want.</li><li>Repeat this process by covering row 0 and pretending row 1 is not the top most row.</li></ol><p>I won't show an example here since once we get to programming we'll be able to run through many examples.</p><h3>Outline</h3><p>I think breaking these steps into there own methods (functions) is a good approach here. We can have:</p><ol><li>Locate leftmost ( not all 0's ) column</li><li>Find row with none 0's value</li><li>Swap rows</li><li>Multiply row by value</li><li>Subtract row by row</li></ol><h3>Locate Left Most Column</h3><p>At first I felt the title line for this method should be:</p><pre><code><div class="highlight"><span></span><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span> <span class="n">_LocateLeftMostNoneZeroColumn</span><span class="p">()</span>
</div></code></pre><p>Now I realize that after the first iteration of our Gaussian Elimination algorithm we will end up with a column with a single 1 and 0's below it but that if we called this method again, it would return the same column back to us. We need a way of telling this method not to consider certain columns. For now I think we can use a single integer to specify which row/column to start with. Now our title line is:</p><pre><code><div class="highlight"><span></span><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span> <span class="n">_LocateLeftMostNoneZeroColumn</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span> <span class="kt">uint32_t</span><span class="o">&gt;</span>  <span class="o">&amp;</span><span class="n">start</span><span class="p">)</span>
</div></code></pre><p>I am using <code>std::optional</code> here in case there does not exist a left most none zero column. In such a case we will return a nil optional.</p><p>The body of this method should be fairly straight forward. We loop over the matrix column by column checking if we can find one with a none 0 row value. Once we find one, return that column.</p><pre><code><div class="highlight"><span></span><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span> <span class="n">_LocateLeftMostNoneZeroColumn</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span> <span class="kt">uint32_t</span><span class="o">&gt;</span>  <span class="o">&amp;</span><span class="n">start</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="k">auto</span> <span class="p">[</span><span class="n">start_row</span><span class="p">,</span> <span class="n">start_col</span><span class="p">]</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">c</span> <span class="o">=</span> <span class="n">start_col</span><span class="p">;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">NumCols</span><span class="p">;</span> <span class="n">c</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">r</span> <span class="o">=</span> <span class="n">start_row</span><span class="p">;</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">NumRows</span><span class="p">;</span> <span class="n">r</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">matrix_</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="n">c</span><span class="p">;</span> 
            <span class="p">}</span>
        <span class="p">}</span> 
    <span class="p">}</span>
    <span class="k">return</span> <span class="p">{};</span>
<span class="p">}</span>
</div></code></pre><h3>Locate Row With None 0 Value</h3><p>Turns out that we already did this work in the previous step, though we did't make use of it. We only returned the column previously but now I am thinking we can return a pair (column, row). Let's modify our title line and function body.</p><pre><code><div class="highlight"><span></span><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span> <span class="kt">uint32_t</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">_LocateNextLeadingOnePosition</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span> <span class="kt">uint32_t</span><span class="o">&gt;</span>  <span class="o">&amp;</span><span class="n">start</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="k">auto</span> <span class="p">[</span><span class="n">start_row</span><span class="p">,</span> <span class="n">start_col</span><span class="p">]</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">c</span> <span class="o">=</span> <span class="n">start_col</span><span class="p">;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">NumCols</span><span class="p">;</span> <span class="n">c</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">r</span> <span class="o">=</span> <span class="n">start_row</span><span class="p">;</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">NumRows</span><span class="p">;</span> <span class="n">r</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">matrix_</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span> 
    <span class="p">}</span>
    <span class="k">return</span> <span class="p">{};</span>
<span class="p">}</span>
</div></code></pre><p>That's better. Killed two steps with 1 function change (as they say).</p><h3>Swap Rows</h3><p>This one is going to require its own function. On the bright side, cpp <code>std::vector</code> comes with a fancy <code>vectorA.swap(vectorB)</code> method (found <a href="https://www.cplusplus.com/reference/vector/vector/swap/">here</a>).</p><p>I think this seems cool, let's use that one.</p><pre><code><div class="highlight"><span></span><span class="kt">void</span> <span class="nf">_SwapRows</span><span class="p">(</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="o">&amp;</span><span class="n">row1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">uint32_t</span> <span class="o">&amp;</span><span class="n">row2</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">matrix_</span><span class="p">[</span><span class="n">row1</span><span class="p">].</span><span class="n">swap</span><span class="p">(</span><span class="n">matrix_</span><span class="p">[</span><span class="n">row2</span><span class="p">]);</span>
<span class="p">}</span>
</div></code></pre><p>The cpp reference website says time complexity for this swap is constant time. Love to see that.</p><h3>Multiply Row by Value</h3><p>This function also seems pretty straight forward. We'll take some value k as an argument and multiply each value in our row by k.</p><pre><code><div class="highlight"><span></span><span class="kt">void</span> <span class="nf">_ScaleRowBy</span><span class="p">(</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="o">&amp;</span><span class="n">row</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="nl">elm</span> <span class="p">:</span> <span class="n">matrix_</span><span class="p">[</span><span class="n">row</span><span class="p">])</span> <span class="p">{</span>
        <span class="n">elm</span> <span class="o">*=</span> <span class="n">k</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</div></code></pre><p>Here <code>elm</code> is a reference to the value in our row. That is why modifying <code>elm</code> modifies the value in our row.</p><p>This function, as it stands, will help for scaling a row by a value. On the other hand, this function fails to solve the Guassian Elimination step which subtracts one row by the scaled version of another. This is because when we want to subtract row A but k * row B, we <strong>don't</strong> want to actually modify row B.</p><p>We deal with this in the next section.</p><h3>Modifying Row A by Another Row</h3><p>I think the idea of modifying a row can occur in different scenarios and therefore making this type of function more generic would be a good idea. I am going to paste my thought below and then go over it:</p><pre><code><div class="highlight"><span></span><span class="kt">void</span> <span class="nf">_ModifyRowBy</span><span class="p">(</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="o">&amp;</span><span class="n">row</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="p">(</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="o">&amp;</span><span class="n">col</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">row_value</span><span class="p">)</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">modifier</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="nl">elm</span> <span class="p">:</span> <span class="n">matrix_</span><span class="p">[</span><span class="n">row</span><span class="p">])</span> <span class="p">{</span>
        <span class="n">elm</span> <span class="o">=</span> <span class="n">modifier</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">elm</span><span class="p">);</span>
        <span class="n">col</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</div></code></pre><p>Alright let's break down the title line. We request that the caller pass in the row they want to modify (first argument) and a function (second argument) which given a column number and a value returns a new value.</p><p>We can then take that new value, and set our rows value to that new value.</p><p>Let's take a look at using our <code>_ModifyRowBy</code> function to perform our "Multiply Row by Value" function.</p><p>Previously our "Multiply Row by Value" function was:</p><pre><code><div class="highlight"><span></span><span class="kt">void</span> <span class="nf">_ScaleRowBy</span><span class="p">(</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="o">&amp;</span><span class="n">row</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="nl">elm</span> <span class="p">:</span> <span class="n">matrix_</span><span class="p">[</span><span class="n">row</span><span class="p">])</span> <span class="p">{</span>
        <span class="n">elm</span> <span class="o">*=</span> <span class="n">k</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</div></code></pre><p>Now it becomes:</p><pre><code><div class="highlight"><span></span><span class="kt">void</span> <span class="nf">_ScaleRowBy</span><span class="p">(</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="o">&amp;</span><span class="n">row</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">_ModifyRowBy</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="p">[</span><span class="o">&amp;</span><span class="n">k</span><span class="p">](</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="o">&amp;</span><span class="n">col</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">old_value</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">old_value</span> <span class="o">*</span> <span class="n">k</span><span class="p">;</span>
    <span class="p">};</span>
<span class="p">}</span>
</div></code></pre><p>No real difference in size, but our new <code>_ModifyRowBy</code> function now allows us to write our "Subtract row by a multiple of another row" function as follows:</p><pre><code><div class="highlight"><span></span><span class="kt">void</span> <span class="nf">_SubtractRowByRowMultiple</span><span class="p">(</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="o">&amp;</span><span class="n">row_to_modify</span><span class="p">,</span> <span class="k">const</span> <span class="kt">uint32_t</span> <span class="o">&amp;</span><span class="n">other_row</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">_ModifyRowBy</span><span class="p">(</span><span class="n">row_to_modify</span><span class="p">,</span> <span class="p">[</span><span class="k">this</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">other_row</span><span class="p">](</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="o">&amp;</span><span class="n">col</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">old_value</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">old_value</span> <span class="o">-</span> <span class="p">(</span><span class="n">matrix_</span><span class="p">[</span><span class="n">other_row</span><span class="p">][</span><span class="n">col</span><span class="p">]</span> <span class="o">*</span> <span class="n">k</span><span class="p">);</span>
    <span class="p">});</span>
<span class="p">}</span>
</div></code></pre><p>Here we tell <code>_ModifyRowBy</code> we want to modify <code>row_to_modify</code>. We then have to capture, <code>this</code>, <code>k</code>, <code>other_row</code> because we want to use them inside our lambda function (between the curly braces).</p><blockquote><p>Note that even though <code>this</code> isnt used explicitly in our lambda, we need it for <code>matrix_</code> since that variable is really <code>this-&gt;matrix_</code>.</p></blockquote><p>Then given some row value <code>old_value</code> we want to subtract <code>k * matrix_[other_row][col]</code> (k times our other row's value).</p><p>With this complete we should be able to chain these functions together and reduce our matrix. Let's hook these functions together and update our <code>main.cpp</code>.</p><h3>Row Echelon Form</h3><p>Our Row echelon form function will be <code>public</code> and look as follows:</p><pre><code><div class="highlight"><span></span><span class="kt">void</span> <span class="nf">ReduceToRowEchelonForm</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
             <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="n">NumRows</span> <span class="o">&amp;&amp;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">NumCols</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="n">leading_1_pos</span> <span class="o">=</span> <span class="n">_LocateNextLeadingOnePosition</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">));</span>

        <span class="c1">// Check if our optional has a value</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">leading_1_pos</span><span class="p">.</span><span class="n">has_value</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// Get values our of our optional</span>
        <span class="k">const</span> <span class="k">auto</span><span class="p">[</span><span class="n">leading_1_row</span><span class="p">,</span> <span class="n">leading_1_col</span><span class="p">]</span> <span class="o">=</span> <span class="n">leading_1_pos</span><span class="p">.</span><span class="n">value</span><span class="p">();</span>

        <span class="c1">// Check if we should swap rows</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">leading_1_row</span> <span class="o">!=</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span> 
            <span class="n">_SwapRows</span><span class="p">(</span><span class="n">leading_1_row</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">// Produce leading 1</span>
        <span class="n">_ScaleRowBy</span><span class="p">(</span><span class="n">leading_1_row</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">matrix_</span><span class="p">[</span><span class="n">leading_1_row</span><span class="p">][</span><span class="n">leading_1_col</span><span class="p">]);</span>
        
        <span class="c1">// Zero out all values below leading 1</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">below_row</span> <span class="o">=</span> <span class="n">leading_1_row</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">below_row</span> <span class="o">&lt;</span> <span class="n">NumRows</span><span class="p">;</span> <span class="n">below_row</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">_SubtractRowByRowMultiple</span><span class="p">(</span><span class="n">below_row</span><span class="p">,</span> <span class="n">leading_1_row</span><span class="p">,</span> <span class="n">matrix_</span><span class="p">[</span><span class="n">below_row</span><span class="p">][</span><span class="n">leading_1_col</span><span class="p">]);</span>
        <span class="p">}</span>

        <span class="n">r</span> <span class="o">=</span> <span class="p">(</span><span class="n">leading_1_row</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">leading_1_col</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</div></code></pre><p>and our <code>main.cpp</code> will be updated to the following:</p><pre><code><div class="highlight"><span></span><span class="cp">#include</span> <span class="cpf">&quot;linalg/matrix.h&quot;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">mathlib</span><span class="o">::</span><span class="n">linalg</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="o">&gt;</span> <span class="n">matrix</span><span class="p">;</span>
    <span class="n">matrix</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">,</span>   <span class="mi">83</span><span class="p">,</span>  <span class="mi">33</span><span class="p">,</span>  <span class="mi">931</span><span class="p">,</span>  <span class="mi">11</span><span class="p">,</span>
              <span class="mi">65</span><span class="p">,</span>  <span class="o">-</span><span class="mi">12</span><span class="p">,</span>   <span class="mi">3</span><span class="p">,</span>   <span class="mi">99</span><span class="p">,</span>   <span class="mi">9</span><span class="p">,</span>
              <span class="mi">81</span><span class="p">,</span>    <span class="mi">5</span><span class="p">,</span> <span class="mi">653</span><span class="p">,</span> <span class="o">-</span><span class="mi">125</span><span class="p">,</span> <span class="mi">271</span><span class="p">,</span>
              <span class="mi">144</span><span class="p">,</span>  <span class="mi">32</span><span class="p">,</span>  <span class="mi">77</span><span class="p">,</span>  <span class="o">-</span><span class="mi">30</span><span class="p">,</span> <span class="o">-</span><span class="mi">15</span><span class="p">,</span>
              <span class="mi">10</span><span class="p">,</span>   <span class="mi">49</span><span class="p">,</span>  <span class="mi">95</span><span class="p">,</span>   <span class="mi">61</span><span class="p">,</span>  <span class="o">-</span><span class="mi">9</span><span class="p">;</span>
              
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;---------------Matrix---------------&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">matrix</span><span class="p">.</span><span class="n">Print</span><span class="p">();</span>
    <span class="n">matrix</span><span class="p">.</span><span class="n">ReduceToRowEchelonForm</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;-------- Row Echelon Form ----------&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">matrix</span><span class="p">.</span><span class="n">Print</span><span class="p">();</span>
<span class="p">}</span>
</div></code></pre><p>Let's give this a whirl!</p><p>Output ( in latex form ):</p><html><header><script type="text/x-mathjax-config">MathJax.Hub.Config({jax: ["input/TeX","output/HTML-CSS"], tex2jax: {inlineMath: [['$$','$$']]} , "HTML-CSS": {linebreaks: {automatic: true}}});</script><script src='https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script></header><body>$$
\begin{bmatrix}
10 & 83 & 33 & 931 & 11\\
65 & -12 & 3 & 99 & 9\\
81 & 5 & 653 & -125 & 271\\
144 & 32 & 77 & -30 & -15\\
10 & 49 & 95 & 61 & -9\\
\end{bmatrix}
$$
$$
\begin{bmatrix}
1 & 0 & 33 & 931 & 11\\
0 & 0 & 1 & 33 & 3\\
-0 & -0 & -0 & 1 & 0.0778813\\
-0 & -0 & -0 & -0 & 1\\
0 & 0 & 0 & 0 & 0\\
\end{bmatrix}
$$</body></html><p>Heyyy! Exactly what we hoped for (minus the minus signs before the 0's)!</p><p>Alright, I think this is a good place to stop for today. Today we implemented Guassian Elimination in our Matrix class. Next up is Gauss-Jordan Elimination. That is only a minor modifcation to Guassian Elimination so hopefully we breeze through that!</p><p>Until then,</p><p>-- Ehud</p>]]></content:encoded></item><item><guid isPermaLink="true">blog.ehudadler.com/linear/matrix</guid><title>1.1 System of Equation and Matricies</title><description>Building the start of a matrix class.</description><link>blog.ehudadler.com/linear/matrix</link><pubDate>Mon, 30 Nov 2020 22:37:00 -0500</pubDate><content:encoded><![CDATA[<p>Alrighty. So here we are. The format I was thinking of going with is: Reading through: <a href="https://www.amazon.com/Elementary-Linear-Algebra-Howard-Anton/dp/0470458216/ref=sr_1_3?dchild=1&keywords=howard+anton&qid=1606782925&sr=8-3">Howard Anton's Elementary Linear Algebra 7th Edition</a> and extending my <code>cpp</code> library as I learn new things.</p><h1>1.1 System of Equation and Matricies</h1><p>In this chapter most of the writing seems to be focused on explaining how systems of equations can be represented as a Matrix. So, here I am going to focus on the Matrix side of things and start our first class. The Matrix class.</p><h2>The Matrix class ( Outline )</h2><p>I want to plan out a bit how this Matrix class will look. In cpp we have the power of non-type template parameters. This means we can pass values (like constants!) into templates rather than types.</p><p>This seems to be the classic convention (see <a href="https://eigen.tuxfamily.org/dox/group__TutorialMatrixClass.html">Eigen</a>) and allows for compile time checks. These compile time checks are actually pretty cool in my opinion. We know (from reading!) that to multiply matricies A &amp; B together, Matrix A must have the <em>exact</em> same number of rows as Matrix B has columns. Since we can pass values (the number of rows and columns) of our matricies in at compile time, we can enforce these constraints then (at compile time) rather than at runtime!</p><p>I also really like how Eigen provides the option to initialize matricies as follows:</p><pre><code><div class="highlight"><span></span><span class="n">Matrix3x3</span> <span class="n">mat</span><span class="p">;</span>
<span class="n">mat</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span>
       <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span>
       <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">;</span>
</div></code></pre><p>So let's try to throw that into our class as well. Well call that "comma initialization" (sounds cool).</p><p>So know how we want to initialize our class, we know how we want to define its size and value type. Time to choose how we want to store the data inside it.</p><p>I had given some thought to storing the values in a single array. Something like:</p><pre><code><div class="highlight"><span></span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">]</span>
</div></code></pre><p>Rather than the classical 2d:</p><pre><code><div class="highlight"><span></span><span class="p">[</span>
    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">]</span>
<span class="p">]</span>
</div></code></pre><p>I think given a row, and column <code>(r, c)</code> getting a value is basically as easy in both cases.</p><p>Keeping with the classic (2d array) seems like the best approach and most straight forward. In <code>swift</code> there is a good reason for going the single array route (Wanting to use <code>ublas/cblas</code> in <code>Accelerate</code>) but the purpose of this class isn't for <code>cpp</code> as much as allowing us to implement some linear algebra so let's go with with the 2d approach.</p><p>I'll use <code>std::vector</code> as my array and create a type-alias so I don't have to continously type the arduous <code>std::vector&lt;std::vector....&gt;</code> each and every time.</p><blockquote><p>Digression: Halfway through this post and I can tell this blog will be teaching me how to spell better.</p></blockquote><p>Anyways, our type-alias will look like this:</p><pre><code><div class="highlight"><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">K</span><span class="o">&gt;</span>
<span class="k">using</span> <span class="n">Dataframe</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">K</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">;</span>
</div></code></pre><p>I'm calling this 2d vector a "Dataframe". I feel like a Dataframe is a more relaxed Matrix. It can take any type of value and it doesn't have any special methods you can call on it. I guess I think of it as the data structure behind a Matrix (??? does that make sense ???).</p><blockquote><p>We use <code>using</code> here rather than <code>typedef</code> because <code>typedef</code> does not work with <code>template</code> parameters.</p></blockquote><p>That is all that we need for section 1.1. Let's begin</p><h2>The Matrix class</h2><h3>Start</h3><p>First off is defining the class. We want the rows, columns, and type being stored to be passed in at compile time via non-type template arguments so lets start there.</p><p>Our template will look something like:</p><pre><code><div class="highlight"><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Type</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">NumRows</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">NumCols</span> <span class="o">=</span> <span class="mi">0</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Matrix</span> <span class="p">{};</span>
</div></code></pre><p>Here we've defined our template to take 3 parameters. The first of the three is the type which the matrix will hold, the second is the number of rows our matrix should have, and the last is the number of columns.</p><p>At the moment (and this is unlikely the change) our matrix will be filled stricly with numeric values. We shouldn't allow the user to pass in <code>std::string</code> or some other types.</p><p>Additionally, we want this check to happen at compile time again. To enable this we will use <code>static_assert</code> to run a check at compile time on the passed in type (<code>Type</code>), verifying that it in indeed a numeric value.</p><p>More specifically, we want the type to be either an integral value (<code>short</code>, <code>int</code>, <code>long</code>, <code>long long</code>..etc) or a floating-point value (<code>float</code>, <code>double</code>...).</p><p>Fortunately for us, <code>cpp</code> has a built in check: <a href="https://en.cppreference.com/w/cpp/types/is_arithmetic">std:: is_arithmetic</a>, which is exactly what we are looking for.</p><p>We end up with something like this,</p><pre><code><div class="highlight"><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Type</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">NumRows</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">NumCols</span> <span class="o">=</span> <span class="mi">0</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Matrix</span> <span class="p">{</span>
    <span class="k">static_assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_arithmetic</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span>
                  <span class="s">&quot;Matrix value must have an integral or floating point type&quot;</span><span class="p">);</span>
<span class="p">};</span> <span class="c1">// Matrix</span>
</div></code></pre><p>This is looking good!</p><p>Let's add in our <code>Dataframe</code> type-alias, and create our instance variable:</p><pre><code><div class="highlight"><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Type</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">NumRows</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">NumCols</span> <span class="o">=</span> <span class="mi">0</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Matrix</span> <span class="p">{</span>

    <span class="c1">// Make sure that the templated `Type` parameter is valid</span>
    <span class="k">static_assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_arithmetic</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span>
                  <span class="s">&quot;Matrix value must have an integral or floating point type&quot;</span><span class="p">);</span>
                  
<span class="k">public</span><span class="o">:</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">K</span><span class="o">&gt;</span>
    <span class="k">using</span> <span class="n">Dataframe</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">K</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">;</span>
    
<span class="k">private</span><span class="o">:</span>    
    <span class="n">Dataframe</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span> <span class="n">matrix_</span><span class="p">;</span>
<span class="p">};</span> <span class="c1">// Matrix</span>
</div></code></pre><p>Since we already know (at compile time) the number of rows and columns, we might as well initialize our <code>matrix_</code> instance variable now.</p><pre><code><div class="highlight"><span></span><span class="c1">// Matrix Class</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Type</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">NumRows</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">NumCols</span> <span class="o">=</span> <span class="mi">0</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Matrix</span> <span class="p">{</span>

    <span class="c1">// Make sure that the templated `Type` parameter is valid</span>
    <span class="k">static_assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_arithmetic</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span>
                  <span class="s">&quot;Matrix value must have an integral or floating point type&quot;</span><span class="p">);</span>
                  
<span class="k">public</span><span class="o">:</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">K</span><span class="o">&gt;</span>
    <span class="k">using</span> <span class="n">Dataframe</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">K</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">;</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">Dataframe</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span> <span class="n">matrix_</span> <span class="o">=</span> <span class="n">Dataframe</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span><span class="p">(</span><span class="n">NumRows</span><span class="p">,</span>
                                           <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span><span class="p">(</span><span class="n">NumCols</span><span class="p">));</span>
<span class="p">};</span> <span class="c1">// Matrix</span>
</div></code></pre><p>Awesome. As narcissistic as I am, it's always good to test to make sure the code you wrote runs. Let's add in some <code>#inlcude</code> and build a <code>main.cpp</code>.</p><pre><code><div class="highlight"><span></span><span class="c1">// Main.cpp</span>

<span class="cp">#include</span> <span class="cpf">&quot;linalg/matrix.h&quot; // Import out lib</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">mathlib</span><span class="o">::</span><span class="n">linalg</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>    <span class="mi">1</span><span class="o">&gt;</span> <span class="n">matrix</span><span class="p">;</span>
                         <span class="c1">// Type   Rows  Cols</span>
<span class="p">}</span>
</div></code></pre><p>Works!</p><p>As hoped, building with:</p><pre><code><div class="highlight"><span></span><span class="c1">// Main.cpp</span>

<span class="cp">#include</span> <span class="cpf">&quot;linalg/matrix.h&quot; // Import out lib</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">mathlib</span><span class="o">::</span><span class="n">linalg</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>    <span class="mi">1</span><span class="o">&gt;</span> <span class="n">matrix</span><span class="p">;</span>
                               <span class="c1">// Type   Rows  Cols</span>
<span class="p">}</span>
</div></code></pre><p>fails with,</p><blockquote><p><code></code><code>error: static_assert failed due to requirement 'std::is_arithmetic&lt;std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; &gt;::value' "Matrix value must have an  integral or floating point type" static_assert(std::is_arithmetic&lt;Type&gt;::value,</code><code></code></p></blockquote><h2>Comma Init</h2><p>Time to initialize. Building the comma init. is 100% unnecessary, but fun. So...</p><p>The idea is as follows:</p><ol><li>We want to overload the <code>&lt;&lt;</code> operator so that when its called on our Matrix class, it returns a new class called CommaInit.</li><li>The CommaInit class has an overloaded <code>,</code> operator which:<ol start="3"><li>Adds the next value to our Matrix</li><li>Returns itself (CommaInit) to pick up the next <code>,</code> (if one exists))</li></ol></li></ol><p>This may seem compilicated, so let's dive into the code side of things and walk through it.</p><h3>Overload <code>&lt;&lt;</code></h3><p>Overloading functions is common in many languages. In <code>cpp</code> we can overload the <code>&lt;&lt;</code> by adding the following into our class:</p><pre><code><div class="highlight"><span></span><span class="n">CommaInit</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">Type</span> <span class="n">v</span><span class="p">)</span> <span class="p">{}</span>
</div></code></pre><p>We have yet to write our <code>CommaInit</code> class but we already know we want our <code>&lt;&lt;</code> overload to return that class type. Additionally we want to kick off this initialization when the type on the right side of the <code>&lt;&lt;</code> matches the type we are storing in our Matrix.</p><p>Recall our goal:</p><pre><code><div class="highlight"><span></span><span class="n">Matrix3x3</span> <span class="n">mat</span><span class="p">;</span>
<span class="n">mat</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span>
       <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span>
       <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">;</span>
</div></code></pre><p>I will put into parenthesis where our operator is taking place:</p><pre><code><div class="highlight"><span></span><span class="p">(</span><span class="n">mat</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span>
         <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span>
         <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">;</span>
</div></code></pre><p>After this operator occurs we will have:</p><pre><code><div class="highlight"><span></span><span class="n">commaInit</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span>
        <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span>
        <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">;</span>
</div></code></pre><p>which is exactly what we want. Now the <code>commaInit</code> object is next to a comma which will kick off that part of the sequence.</p><p>Before getting ahead of ourselves let's finish implementing the overload.</p><p>Notice how the first value (the <code>1</code>) is gone after the overloaded function finishes. This means we need to place that value into our matrix before the overloaded function ends.</p><pre><code><div class="highlight"><span></span><span class="n">CommaInit</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">Type</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
<span class="p">}</span>
</div></code></pre><p>Now we must create the <code>CommaInit</code> object and return it. One thing we know is that at this point the <code>CommaInit</code> class is about to take over and we still somehow need a way of altering the <code>matrix_</code>. To achieve this we will pass the address og our <code>matrix_</code> into the <code>CommaInit</code> constructor. This will allow <code>CommaInit</code> to mutate our <code>matrix_</code>.</p><pre><code><div class="highlight"><span></span><span class="n">CommaInit</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">Type</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">matrix_</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
    <span class="k">return</span> <span class="nf">CommaInit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">matrix_</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> 
    <span class="c1">// The 1 here denotes that we are upto the 1th index of our matrix.</span>
    <span class="c1">// We already ingested the 0th index on the line before.</span>
<span class="p">}</span>
</div></code></pre><p>All that is left is to create the <code>CommaInit</code> class. I wont walk through this part exactly but the class is small and hopefully understandable:</p><pre><code><div class="highlight"><span></span><span class="k">struct</span> <span class="n">CommaInit</span> <span class="p">{</span>
    <span class="n">Dataframe</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">df</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">index</span><span class="p">;</span>
    <span class="n">CommaInit</span><span class="p">(</span><span class="n">Dataframe</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">df</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">index</span><span class="p">)</span> 
    <span class="o">:</span> <span class="n">df</span><span class="p">(</span><span class="n">df</span><span class="p">),</span> <span class="n">index</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="p">{};</span>
    
    <span class="c1">// Overload the , operator</span>
    <span class="n">CommaInit</span> <span class="k">operator</span><span class="p">,(</span><span class="n">Type</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">(</span><span class="o">*</span><span class="n">df</span><span class="p">)[</span><span class="n">index</span> <span class="o">/</span> <span class="n">NumCols</span><span class="p">][</span><span class="n">index</span> <span class="o">%</span> <span class="n">NumCols</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
        <span class="k">return</span> <span class="nf">CommaInit</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// Recursion-like</span>
    <span class="p">}</span>
<span class="p">};</span>
</div></code></pre><p>Let's add this to our Matrix class and try updating our <code>main.cpp</code></p><pre><code><div class="highlight"><span></span><span class="c1">// Matrix Class</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Type</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">NumRows</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">NumCols</span> <span class="o">=</span> <span class="mi">0</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Matrix</span> <span class="p">{</span>

    <span class="c1">// Make sure that the templated `Type` parameter is valid</span>
    <span class="k">static_assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_arithmetic</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span>
                  <span class="s">&quot;Matrix value must have an integral or floating point type&quot;</span><span class="p">);</span>
                  
<span class="k">public</span><span class="o">:</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">K</span><span class="o">&gt;</span>
    <span class="k">using</span> <span class="n">Dataframe</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">K</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">;</span>

    <span class="k">struct</span> <span class="n">CommaInit</span> <span class="p">{</span>
        <span class="n">Dataframe</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">df</span><span class="p">;</span>
        <span class="kt">uint32_t</span> <span class="n">index</span><span class="p">;</span>
        <span class="n">CommaInit</span><span class="p">(</span><span class="n">Dataframe</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">df</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">index</span><span class="p">)</span> 
        <span class="o">:</span> <span class="n">df</span><span class="p">(</span><span class="n">df</span><span class="p">),</span> <span class="n">index</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="p">{};</span>
        
        <span class="c1">// Overload the , operator</span>
        <span class="n">CommaInit</span> <span class="k">operator</span><span class="p">,(</span><span class="n">Type</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
            <span class="p">(</span><span class="o">*</span><span class="n">df</span><span class="p">)[</span><span class="n">index</span> <span class="o">/</span> <span class="n">NumCols</span><span class="p">][</span><span class="n">index</span> <span class="o">%</span> <span class="n">NumCols</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
            <span class="k">return</span> <span class="nf">CommaInit</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// Recursion-like</span>
        <span class="p">}</span>
    <span class="p">};</span>
    <span class="c1">// Everything here will be public</span>
    <span class="n">CommaInit</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">Type</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">matrix_</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
        <span class="k">return</span> <span class="nf">CommaInit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">matrix_</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> 
        <span class="c1">// The 1 here denotes that we are upto the 1th index of our matrix.</span>
        <span class="c1">// We already ingested the 0th index on the line before.</span>
    <span class="p">}</span>
<span class="k">private</span><span class="o">:</span>    
    <span class="n">Dataframe</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span> <span class="n">matrix_</span> <span class="o">=</span> <span class="n">Dataframe</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span><span class="p">(</span><span class="n">NumRows</span><span class="p">,</span>
                                           <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span><span class="p">(</span><span class="n">NumCols</span><span class="p">));</span>
<span class="p">};</span> <span class="c1">// Matrix</span>
</div></code></pre><pre><code><div class="highlight"><span></span><span class="c1">// main.cpp</span>
<span class="cp">#include</span> <span class="cpf">&quot;linalg/matrix.h&quot;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">mathlib</span><span class="o">::</span><span class="n">linalg</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="n">matrix</span>
    <span class="n">matrix</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</div></code></pre><p>Seems to work. Let's confirm by adding a <code>Print</code> function which prints our matrix. Again, I'll just show the function. Nothing special here.</p><pre><code><div class="highlight"><span></span><span class="kt">void</span> <span class="nf">Print</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NumRows</span> <span class="o">*</span> <span class="n">NumCols</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">matrix_</span><span class="p">[</span><span class="n">i</span> <span class="o">/</span> <span class="n">NumCols</span><span class="p">][</span><span class="n">i</span> <span class="o">%</span> <span class="n">NumCols</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">NumCols</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</div></code></pre><p>We get,</p><pre><code><div class="highlight"><span></span><span class="c1">// Matrix Class</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Type</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">NumRows</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">NumCols</span> <span class="o">=</span> <span class="mi">0</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Matrix</span> <span class="p">{</span>

    <span class="c1">// Make sure that the templated `Type` parameter is valid</span>
    <span class="k">static_assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_arithmetic</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span>
                  <span class="s">&quot;Matrix value must have an integral or floating point type&quot;</span><span class="p">);</span>
                  
<span class="k">public</span><span class="o">:</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">K</span><span class="o">&gt;</span>
    <span class="k">using</span> <span class="n">Dataframe</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">K</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">;</span>

    <span class="p">...</span> <span class="n">See</span> <span class="n">above</span> <span class="k">for</span> <span class="n">other</span> <span class="n">code</span>
    
    <span class="kt">void</span> <span class="n">Print</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NumRows</span> <span class="o">*</span> <span class="n">NumCols</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">matrix_</span><span class="p">[</span><span class="n">i</span> <span class="o">/</span> <span class="n">NumCols</span><span class="p">][</span><span class="n">i</span> <span class="o">%</span> <span class="n">NumCols</span><span class="p">];</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">NumCols</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="k">private</span><span class="o">:</span>    
    <span class="n">Dataframe</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span> <span class="n">matrix_</span> <span class="o">=</span> <span class="n">Dataframe</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span><span class="p">(</span><span class="n">NumRows</span><span class="p">,</span>
                                           <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span><span class="p">(</span><span class="n">NumCols</span><span class="p">));</span>
<span class="p">};</span> <span class="c1">// Matrix</span>
</div></code></pre><pre><code><div class="highlight"><span></span><span class="c1">// main.cpp</span>

<span class="cp">#include</span> <span class="cpf">&quot;linalg/matrix.h&quot;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">mathlib</span><span class="o">::</span><span class="n">linalg</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">matrix</span><span class="p">;</span>
    <span class="n">matrix</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span>
              <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span>
              <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">;</span>
    <span class="n">matrix</span><span class="p">.</span><span class="n">Print</span><span class="p">();</span>
<span class="p">}</span>
</div></code></pre><p>Running this give:</p><pre><code><div class="highlight"><span></span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span>
<span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span>
<span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span>
</div></code></pre><p>Exactly what we hoped for.</p><p>It's getting late and I feel this was a good start at our matrix class. Section 1.2 deals with Gaussian Elimination so looks like that is our next step!</p><p>-- Ehud</p>]]></content:encoded></item><item><guid isPermaLink="true">blog.ehudadler.com/general/hello</guid><title>Hello.</title><description>This blog.</description><link>blog.ehudadler.com/general/hello</link><pubDate>Sat, 28 Nov 2020 18:47:00 -0500</pubDate><content:encoded><![CDATA[<h1>Hello.</h1><p>I see how it maybe confusing that this blog has 2 posts which start off "Hello.".</p><p>To be honest, originally the "Hello World" post for this blog was supposed to be the one you can now find in the linear algebra section of this site. That is because the original idea to start this blog came from want to share a journey of linear algebra with the world.</p><p>Change of plans.</p><p>I enjoyed writing out my Hello Linear Algebra post and decided if I was going to have a chance in being "active" on this site, I'd need a few more topics to chat about. So here we are.</p><p>I obviously will continue (start :) ) the Linear Algebra series of this blog but I will additionally add a "Interview Questions" and General section.</p><p>The interview section i'm sure (NOT) will come as a shock to those who know me.</p><p>The general section is here because sometimes what I want to say wont fit into an on-going series.</p><p>With that said, I encourage you to read the OG Hello post located in the Linear Algebra series and enjoy!</p><p>-- Ehud</p>]]></content:encoded></item><item><guid isPermaLink="true">blog.ehudadler.com/linear/a-journey-begins</guid><title>A journey begins</title><description>The start of a long journey.</description><link>blog.ehudadler.com/linear/a-journey-begins</link><pubDate>Sat, 28 Nov 2020 18:47:00 -0500</pubDate><content:encoded><![CDATA[<h1>Hello.</h1><h2>Here we go again..</h2><p>Although the number of times I have tried to start a blog <em>can</em> be counted on one hand, I already recognize (at least to some extent) the time and energy that goes into writing one.</p><p>In the past I feel I've chosen general topics which although interesting, did not exert a strong enough pull on me to write. Naturally, I am hoping this time is different.</p><h2>Whoami</h2><p>Hi. My name is Ehud Adler and as I write this I am currently at home, during the later stages of a world wide pandemic (the corona virus). I graduated from Queens College (CUNY) almost 6 months ago and started my full-time employment at Apple.</p><p>When I was in high-school I was what you may call a poor student. I won't say "bad", because that sounds to me as if I was a trouble maker. I was not. I just wasn't so into homework, studying etc.</p><p>I did well in subjects I was interested in and did fine in the rest. I wasn't a failing student, just not top of the class. One subject I never did well in was Math.</p><p>Not much changed in terms of studying until I took a gap year in Israel. My days in Israel we're filled with sitting, focusing and analytical learning. All of a sudden I was actually willing to sit down and study and learn. This bode well for my future college career.</p><p>With my new ability to study I began college and pursuit of a CS degree on the right foot. I took Calculus I in my first semester and got an A! Although this shocked me (and most likely my parents), I still was not a lover of math. Something about calculus just didn't draw me in the way applied math (computer science) did. At Queens, and most likely at many other colleges, Computer Science and Math overlap enough that a common track for students to take is CS Major + Math Minor (or the opposite). One semester in and I realized, that wasn't me.</p><p>Second semester rolls around and I decide to take 2 math courses. Calc II and Linear Algebra. Calc II was easier than Calc I for me (maybe it was the professor). I enjoyed it, but not enough to change my mind on getting a Math minor. That change of mind came from Linear Algebra.</p><p>Linear Algebra changed my college career. I find it interesting that although I enjoy Applied Math (Computer Science), it was abstract math (Linear Algebra) which won my love.</p><p>That semester I changed my college path. I was going to double major.</p><p>Since that linear class I've taken: Multi-variable Calc, Vector Calc, Abstract Algebra, Number Theory, Stat I, Stat II</p><p>It probably wouldn't shock you if I told you my favorites were: Abstract Algebra and Number Theory.</p><p>So with that background on me, let's get into the idea behind this blog</p><h2>The idea behind this blog</h2><p>Recently I picked up my Linear Algebra textbook. I read it once a week, slowly making my way through it again. Being slighlty more confident in writing Cpp I found myself thinking about how I would program Gaussian Elimination, Matrix Multiplication, etc. I thought, maybe I should write a cpp linear algebra library. I know professional ones exist but I've always been one of those people who learns best from doing.</p><p>This blog is my attempt to share my journey writing math libraries in cpp. I will work through my favorite math textbooks, implementing the mathematical algorithms/concepts in code when I see fit.</p><p>I will add a disclaimer that I won't be looking to necessarily write the most efficient or beauitful code. That can always come later.</p><p>That being said, feedback and comments are always welcome!</p><p>-- Ehud A.</p>]]></content:encoded></item></channel></rss>