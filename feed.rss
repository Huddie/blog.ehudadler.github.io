<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content"><channel><title>Ramble Ramble</title><description>Learning everyday</description><link>blog.ehudadler.com</link><language>en</language><lastBuildDate>Mon, 30 Nov 2020 23:38:50 -0500</lastBuildDate><pubDate>Mon, 30 Nov 2020 23:38:50 -0500</pubDate><ttl>250</ttl><atom:link href="blog.ehudadler.com/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">blog.ehudadler.com/linear/matrix</guid><title>1.1 System of Equation and Matricies</title><description>Building the start of a matrix class.</description><link>blog.ehudadler.com/linear/matrix</link><pubDate>Mon, 30 Nov 2020 22:37:00 -0500</pubDate><content:encoded><![CDATA[<p>Alrighty. So here we are. The format I was thinking of going with is: Reading through: <a href="https://www.amazon.com/Elementary-Linear-Algebra-Howard-Anton/dp/0470458216/ref=sr_1_3?dchild=1&keywords=howard+anton&qid=1606782925&sr=8-3">Howard Anton's Elementary Linear Algebra 7th Edition</a> and extending my <code>cpp</code> library as I learn new things.</p><h1>1.1 System of Equation and Matricies</h1><p>In this chapter most of the writing seems to be focused on explaining how systems of equations can be represented as a Matrix. So, here I am going to focus on the Matrix side of things and start our first class. The Matrix class.</p><h2>The Matrix class (Outline)</h2><p>I want to plan out a bit how this Matrix class will look. In cpp we have the power of non-type template parameters. This means we can pass values (like constants!) into templates rather than types.</p><p>This seems to be the classic convention (see <a href="https://eigen.tuxfamily.org/dox/group__TutorialMatrixClass.html">Eigen</a>) and allows for compile time checks. These compile time checks are actually pretty cool in my opinion. We know (from reading!) that to multiply matricies A &amp; B together, Matrix A must have the <em>exact</em> same number of rows as Matrix B has columns. Since we can pass values (the number of rows and columns) of our matricies in at compile time, we can enforce these constraints then (at compile time) rather than at runtime!</p><p>I also really like how Eigen provides the option to initialize matricies as follows:</p><pre><code><div class="highlight"><span></span><span class="n">Matrix3x3</span> <span class="n">mat</span><span class="p">;</span>
<span class="n">mat</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span>
       <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span>
       <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">;</span>
</div></code></pre><p>So let's try to throw that into our class as well. Well call that "comma initialization" (sounds cool).</p><p>So know how we want to initialize our class, we know how we want to define its size and value type. Time to choose how we want to store the data inside it.</p><p>I had given some thought to storing the values in a single array. Something like:</p><pre><code><div class="highlight"><span></span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">]</span>
</div></code></pre><p>Rather than the classical 2d:</p><pre><code><div class="highlight"><span></span><span class="p">[</span>
    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">]</span>
<span class="p">]</span>
</div></code></pre><p>I think given a row, and column <code>(r, c)</code> getting a value is basically as easy in both cases.</p><p>Keeping with the classic (2d array) seems like the best approach and most straight forward. In <code>swift</code> there is a good reason for going the single array route (Wanting to use <code>ublas/cblas</code> in <code>Accelerate</code>) but the purpose of this class isn't for <code>cpp</code> as much as allowing us to implement some linear algebra so let's go with with the 2d approach.</p><p>I'll use <code>std::vector</code> as my array and create a type-alias so I don't have to continously type the arduous <code>std::vector&lt;std::vector....&gt;</code> each and every time.</p><blockquote><p>Digression: Halfway through this post and I can tell this blog will be teaching me how to spell better.</p></blockquote><p>Anyways, our type-alias will look like this:</p><pre><code><div class="highlight"><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">K</span><span class="o">&gt;</span>
<span class="k">using</span> <span class="n">Dataframe</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">K</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">;</span>
</div></code></pre><p>I'm calling this 2d vector a "Dataframe". I feel like a Dataframe is a more relaxed Matrix. It can take any type of value and it doesn't have any special methods you can call on it. I guess I think of it as the data structure behind a Matrix (??? does that make sense ???).</p><blockquote><p>We use <code>using</code> here rather than <code>typedef</code> because <code>typedef</code> does not work with <code>template</code> parameters.</p></blockquote><p>That is all that we need for section 1.1. Let's begin</p><h2>The Matrix class</h2><h3>Start</h3><p>First off is defining the class. We want the rows, columns, and type being stored to be passed in at compile time via non-type template arguments so lets start there.</p><p>Our template will look something like:</p><pre><code><div class="highlight"><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Type</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">NumRows</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">NumCols</span> <span class="o">=</span> <span class="mi">0</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Matrix</span> <span class="p">{};</span>
</div></code></pre><p>Here we've defined our template to take 3 parameters. The first of the three is the type which the matrix will hold, the second is the number of rows our matrix should have, and the last is the number of columns.</p><p>At the moment (and this is unlikely the change) our matrix will be filled stricly with numeric values. We shouldn't allow the user to pass in <code>std::string</code> or some other types.</p><p>Additionally, we want this check to happen at compile time again. To enable this we will use <code>static_assert</code> to run a check at compile time on the passed in type (<code>Type</code>), verifying that it in indeed a numeric value.</p><p>More specifically, we want the type to be either an integral value (<code>short</code>, <code>int</code>, <code>long</code>, <code>long long</code>..etc) or a floating-point value (<code>float</code>, <code>double</code>...).</p><p>Fortunately for us, <code>cpp</code> has a built in check: <a href="https://en.cppreference.com/w/cpp/types/is_arithmetic">std:: is_arithmetic</a>, which is exactly what we are looking for.</p><p>We end up with something like this,</p><pre><code><div class="highlight"><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Type</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">NumRows</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">NumCols</span> <span class="o">=</span> <span class="mi">0</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Matrix</span> <span class="p">{</span>
    <span class="k">static_assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_arithmetic</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span>
                  <span class="s">&quot;Matrix value must have an integral or floating point type&quot;</span><span class="p">);</span>
<span class="p">};</span> <span class="c1">// Matrix</span>
</div></code></pre><p>This is looking good!</p><p>Let's add in our <code>Dataframe</code> type-alias, and create our instance variable:</p><pre><code><div class="highlight"><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Type</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">NumRows</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">NumCols</span> <span class="o">=</span> <span class="mi">0</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Matrix</span> <span class="p">{</span>

    <span class="c1">// Make sure that the templated `Type` parameter is valid</span>
    <span class="k">static_assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_arithmetic</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span>
                  <span class="s">&quot;Matrix value must have an integral or floating point type&quot;</span><span class="p">);</span>
                  
<span class="k">public</span><span class="o">:</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">K</span><span class="o">&gt;</span>
    <span class="k">using</span> <span class="n">Dataframe</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">K</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">;</span>
    
<span class="k">private</span><span class="o">:</span>    
    <span class="n">Dataframe</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span> <span class="n">matrix_</span><span class="p">;</span>
<span class="p">};</span> <span class="c1">// Matrix</span>
</div></code></pre><p>Since we already know (at compile time) the number of rows and columns, we might as well initialize our <code>matrix_</code> instance variable now.</p><pre><code><div class="highlight"><span></span><span class="c1">// Matrix Class</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Type</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">NumRows</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">NumCols</span> <span class="o">=</span> <span class="mi">0</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Matrix</span> <span class="p">{</span>

    <span class="c1">// Make sure that the templated `Type` parameter is valid</span>
    <span class="k">static_assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_arithmetic</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span>
                  <span class="s">&quot;Matrix value must have an integral or floating point type&quot;</span><span class="p">);</span>
                  
<span class="k">public</span><span class="o">:</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">K</span><span class="o">&gt;</span>
    <span class="k">using</span> <span class="n">Dataframe</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">K</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">;</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">Dataframe</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span> <span class="n">matrix_</span> <span class="o">=</span> <span class="n">Dataframe</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span><span class="p">(</span><span class="n">NumRows</span><span class="p">,</span>
                                           <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span><span class="p">(</span><span class="n">NumCols</span><span class="p">));</span>
<span class="p">};</span> <span class="c1">// Matrix</span>
</div></code></pre><p>Awesome. As narcissistic as I am, it's always good to test to make sure the code you wrote runs. Let's add in some <code>#inlcude</code> and build a <code>main.cpp</code>.</p><pre><code><div class="highlight"><span></span><span class="c1">// Main.cpp</span>

<span class="cp">#include</span> <span class="cpf">&quot;linalg/matrix.h&quot; // Import out lib</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">mathlib</span><span class="o">::</span><span class="n">linalg</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>    <span class="mi">1</span><span class="o">&gt;</span> <span class="n">matrix</span><span class="p">;</span>
                         <span class="c1">// Type   Rows  Cols</span>
<span class="p">}</span>
</div></code></pre><p>Works!</p><p>As hoped, building with:</p><pre><code><div class="highlight"><span></span><span class="c1">// Main.cpp</span>

<span class="cp">#include</span> <span class="cpf">&quot;linalg/matrix.h&quot; // Import out lib</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">mathlib</span><span class="o">::</span><span class="n">linalg</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>    <span class="mi">1</span><span class="o">&gt;</span> <span class="n">matrix</span><span class="p">;</span>
                               <span class="c1">// Type   Rows  Cols</span>
<span class="p">}</span>
</div></code></pre><p>fails with,</p><blockquote><p><code></code><code>error: static_assert failed due to requirement 'std::is_arithmetic&lt;std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; &gt;::value' "Matrix value must have an  integral or floating point type" static_assert(std::is_arithmetic&lt;Type&gt;::value,</code><code></code></p></blockquote><h2>Comma Init</h2><p>Time to initialize. Building the comma init. is 100% unnecessary, but fun. So...</p><p>The idea is as follows:</p><ol><li>We want to overload the <code>&lt;&lt;</code> operator so that when its called on our Matrix class, it returns a new class called CommaInit.</li><li>The CommaInit class has an overloaded <code>,</code> operator which:<ol start="3"><li>Adds the next value to our Matrix</li><li>Returns itself (CommaInit) to pick up the next <code>,</code> (if one exists))</li></ol></li></ol><p>This may seem compilicated, so let's dive into the code side of things and walk through it.</p><h3>Overload <code>&lt;&lt;</code></h3><p>Overloading functions is common in many languages. In <code>cpp</code> we can overload the <code>&lt;&lt;</code> by adding the following into our class:</p><pre><code><div class="highlight"><span></span><span class="n">CommaInit</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">Type</span> <span class="n">v</span><span class="p">)</span> <span class="p">{}</span>
</div></code></pre><p>We have yet to write our <code>CommaInit</code> class but we already know we want our <code>&lt;&lt;</code> overload to return that class type. Additionally we want to kick off this initialization when the type on the right side of the <code>&lt;&lt;</code> matches the type we are storing in our Matrix.</p><p>Recall our goal:</p><pre><code><div class="highlight"><span></span><span class="n">Matrix3x3</span> <span class="n">mat</span><span class="p">;</span>
<span class="n">mat</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span>
       <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span>
       <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">;</span>
</div></code></pre><p>I will put into parenthesis where our operator is taking place:</p><pre><code><div class="highlight"><span></span><span class="p">(</span><span class="n">mat</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span>
         <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span>
         <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">;</span>
</div></code></pre><p>After this operator occurs we will have:</p><pre><code><div class="highlight"><span></span><span class="n">commaInit</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span>
        <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span>
        <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">;</span>
</div></code></pre><p>which is exactly what we want. Now the <code>commaInit</code> object is next to a comma which will kick off that part of the sequence.</p><p>Before getting ahead of ourselves let's finish implementing the overload.</p><p>Notice how the first value (the <code>1</code>) is gone after the overloaded function finishes. This means we need to place that value into our matrix before the overloaded function ends.</p><pre><code><div class="highlight"><span></span><span class="n">CommaInit</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">Type</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
<span class="p">}</span>
</div></code></pre><p>Now we must create the <code>CommaInit</code> object and return it. One thing we know is that at this point the <code>CommaInit</code> class is about to take over and we still somehow need a way of altering the <code>matrix_</code>. To achieve this we will pass the address og our <code>matrix_</code> into the <code>CommaInit</code> constructor. This will allow <code>CommaInit</code> to mutate our <code>matrix_</code>.</p><pre><code><div class="highlight"><span></span><span class="n">CommaInit</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">Type</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">matrix_</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
    <span class="k">return</span> <span class="nf">CommaInit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">matrix_</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> 
    <span class="c1">// The 1 here denotes that we are upto the 1th index of our matrix.</span>
    <span class="c1">// We already ingested the 0th index on the line before.</span>
<span class="p">}</span>
</div></code></pre><p>All that is left is to create the <code>CommaInit</code> class. I wont walk through this part exactly but the class is small and hopefully understandable:</p><pre><code><div class="highlight"><span></span><span class="k">struct</span> <span class="n">CommaInit</span> <span class="p">{</span>
    <span class="n">Dataframe</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">df</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">index</span><span class="p">;</span>
    <span class="n">CommaInit</span><span class="p">(</span><span class="n">Dataframe</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">df</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">index</span><span class="p">)</span> 
    <span class="o">:</span> <span class="n">df</span><span class="p">(</span><span class="n">df</span><span class="p">),</span> <span class="n">index</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="p">{};</span>
    
    <span class="c1">// Overload the , operator</span>
    <span class="n">CommaInit</span> <span class="k">operator</span><span class="p">,(</span><span class="n">Type</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">(</span><span class="o">*</span><span class="n">df</span><span class="p">)[</span><span class="n">index</span> <span class="o">/</span> <span class="n">NumCols</span><span class="p">][</span><span class="n">index</span> <span class="o">%</span> <span class="n">NumCols</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
        <span class="k">return</span> <span class="nf">CommaInit</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// Recursion-like</span>
    <span class="p">}</span>
<span class="p">};</span>
</div></code></pre><p>Let's add this to our Matrix class and try updating our <code>main.cpp</code></p><pre><code><div class="highlight"><span></span><span class="c1">// Matrix Class</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Type</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">NumRows</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">NumCols</span> <span class="o">=</span> <span class="mi">0</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Matrix</span> <span class="p">{</span>

    <span class="c1">// Make sure that the templated `Type` parameter is valid</span>
    <span class="k">static_assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_arithmetic</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span>
                  <span class="s">&quot;Matrix value must have an integral or floating point type&quot;</span><span class="p">);</span>
                  
<span class="k">public</span><span class="o">:</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">K</span><span class="o">&gt;</span>
    <span class="k">using</span> <span class="n">Dataframe</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">K</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">;</span>

    <span class="k">struct</span> <span class="n">CommaInit</span> <span class="p">{</span>
        <span class="n">Dataframe</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">df</span><span class="p">;</span>
        <span class="kt">uint32_t</span> <span class="n">index</span><span class="p">;</span>
        <span class="n">CommaInit</span><span class="p">(</span><span class="n">Dataframe</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">df</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">index</span><span class="p">)</span> 
        <span class="o">:</span> <span class="n">df</span><span class="p">(</span><span class="n">df</span><span class="p">),</span> <span class="n">index</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="p">{};</span>
        
        <span class="c1">// Overload the , operator</span>
        <span class="n">CommaInit</span> <span class="k">operator</span><span class="p">,(</span><span class="n">Type</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
            <span class="p">(</span><span class="o">*</span><span class="n">df</span><span class="p">)[</span><span class="n">index</span> <span class="o">/</span> <span class="n">NumCols</span><span class="p">][</span><span class="n">index</span> <span class="o">%</span> <span class="n">NumCols</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
            <span class="k">return</span> <span class="nf">CommaInit</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// Recursion-like</span>
        <span class="p">}</span>
    <span class="p">};</span>
    <span class="c1">// Everything here will be public</span>
    <span class="n">CommaInit</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">Type</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">matrix_</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
        <span class="k">return</span> <span class="nf">CommaInit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">matrix_</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> 
        <span class="c1">// The 1 here denotes that we are upto the 1th index of our matrix.</span>
        <span class="c1">// We already ingested the 0th index on the line before.</span>
    <span class="p">}</span>
<span class="k">private</span><span class="o">:</span>    
    <span class="n">Dataframe</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span> <span class="n">matrix_</span> <span class="o">=</span> <span class="n">Dataframe</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span><span class="p">(</span><span class="n">NumRows</span><span class="p">,</span>
                                           <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span><span class="p">(</span><span class="n">NumCols</span><span class="p">));</span>
<span class="p">};</span> <span class="c1">// Matrix</span>
</div></code></pre><pre><code><div class="highlight"><span></span><span class="c1">// main.cpp</span>
<span class="cp">#include</span> <span class="cpf">&quot;linalg/matrix.h&quot;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">mathlib</span><span class="o">::</span><span class="n">linalg</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="n">matrix</span>
    <span class="n">matrix</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</div></code></pre><p>Seems to work. Let's confirm by adding a <code>Print</code> function which prints our matrix. Again, I'll just show the function. Nothing special here.</p><pre><code><div class="highlight"><span></span><span class="kt">void</span> <span class="nf">Print</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NumRows</span> <span class="o">*</span> <span class="n">NumCols</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">matrix_</span><span class="p">[</span><span class="n">i</span> <span class="o">/</span> <span class="n">NumCols</span><span class="p">][</span><span class="n">i</span> <span class="o">%</span> <span class="n">NumCols</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">NumCols</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</div></code></pre><p>We get,</p><pre><code><div class="highlight"><span></span><span class="c1">// Matrix Class</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Type</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">NumRows</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">NumCols</span> <span class="o">=</span> <span class="mi">0</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Matrix</span> <span class="p">{</span>

    <span class="c1">// Make sure that the templated `Type` parameter is valid</span>
    <span class="k">static_assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_arithmetic</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span>
                  <span class="s">&quot;Matrix value must have an integral or floating point type&quot;</span><span class="p">);</span>
                  
<span class="k">public</span><span class="o">:</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">K</span><span class="o">&gt;</span>
    <span class="k">using</span> <span class="n">Dataframe</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">K</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">;</span>

    <span class="p">...</span> <span class="n">See</span> <span class="n">above</span> <span class="k">for</span> <span class="n">other</span> <span class="n">code</span>
    
    <span class="kt">void</span> <span class="n">Print</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NumRows</span> <span class="o">*</span> <span class="n">NumCols</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">matrix_</span><span class="p">[</span><span class="n">i</span> <span class="o">/</span> <span class="n">NumCols</span><span class="p">][</span><span class="n">i</span> <span class="o">%</span> <span class="n">NumCols</span><span class="p">];</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">NumCols</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="k">private</span><span class="o">:</span>    
    <span class="n">Dataframe</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span> <span class="n">matrix_</span> <span class="o">=</span> <span class="n">Dataframe</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span><span class="p">(</span><span class="n">NumRows</span><span class="p">,</span>
                                           <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span><span class="p">(</span><span class="n">NumCols</span><span class="p">));</span>
<span class="p">};</span> <span class="c1">// Matrix</span>
</div></code></pre><pre><code><div class="highlight"><span></span><span class="c1">// main.cpp</span>

<span class="cp">#include</span> <span class="cpf">&quot;linalg/matrix.h&quot;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">mathlib</span><span class="o">::</span><span class="n">linalg</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">matrix</span><span class="p">;</span>
    <span class="n">matrix</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span>
              <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span>
              <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">;</span>
    <span class="n">matrix</span><span class="p">.</span><span class="n">Print</span><span class="p">();</span>
<span class="p">}</span>
</div></code></pre><p>Running this give:</p><pre><code><div class="highlight"><span></span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span>
<span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span>
<span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span>
</div></code></pre><p>Exactly what we hoped for.</p><p>It's getting late and I feel this was a good start at our matrix class. Section 1.2 deals with Gaussian Elimination so looks like that is our next step!</p><p>-- Ehud</p>]]></content:encoded></item><item><guid isPermaLink="true">blog.ehudadler.com/general/hello</guid><title>Hello.</title><description>This blog.</description><link>blog.ehudadler.com/general/hello</link><pubDate>Sat, 28 Nov 2020 18:47:00 -0500</pubDate><content:encoded><![CDATA[<h1>Hello.</h1><p>I see how it maybe confusing that this blog has 2 posts which start off "Hello.".</p><p>To be honest, originally the "Hello World" post for this blog was supposed to be the one you can now find in the linear algebra section of this site. That is because the original idea to start this blog came from want to share a journey of linear algebra with the world.</p><p>Change of plans.</p><p>I enjoyed writing out my Hello Linear Algebra post and decided if I was going to have a chance in being "active" on this site, I'd need a few more topics to chat about. So here we are.</p><p>I obviously will continue (start :) ) the Linear Algebra series of this blog but I will additionally add a "Interview Questions" and General section.</p><p>The interview section i'm sure (NOT) will come as a shock to those who know me.</p><p>The general section is here because sometimes what I want to say wont fit into an on-going series.</p><p>With that said, I encourage you to read the OG Hello post located in the Linear Algebra series and enjoy!</p><p>-- Ehud</p>]]></content:encoded></item><item><guid isPermaLink="true">blog.ehudadler.com/linear/a-journey-begins</guid><title>Hello.</title><description>The start of a long journey.</description><link>blog.ehudadler.com/linear/a-journey-begins</link><pubDate>Sat, 28 Nov 2020 18:47:00 -0500</pubDate><content:encoded><![CDATA[<h1>Hello.</h1><h2>Here we go again..</h2><p>Although the number of times I have tried to start a blog <em>can</em> be counted on one hand, I already recognize (at least to some extent) the time and energy that goes into writing one.</p><p>In the past I feel I've chosen general topics which although interesting, did not exert a strong enough pull on me to write. Naturally, I am hoping this time is different.</p><h2>Whoami</h2><p>Hi. My name is Ehud Adler and as I write this I am currently at home, during the later stages of a world wide pandemic (the corona virus). I graduated from Queens College (CUNY) almost 6 months ago and started my full-time employment at Apple.</p><p>When I was in high-school I was what you may call a poor student. I won't say "bad", because that sounds to me as if I was a trouble maker. I was not. I just wasn't so into homework, studying etc.</p><p>I did well in subjects I was interested in and did fine in the rest. I wasn't a failing student, just not top of the class. One subject I never did well in was Math.</p><p>Not much changed in terms of studying until I took a gap year in Israel. My days in Israel we're filled with sitting, focusing and analytical learning. All of a sudden I was actually willing to sit down and study and learn. This bode well for my future college career.</p><p>With my new ability to study I began college and pursuit of a CS degree on the right foot. I took Calculus I in my first semester and got an A! Although this shocked me (and most likely my parents), I still was not a lover of math. Something about calculus just didn't draw me in the way applied math (computer science) did. At Queens, and most likely at many other colleges, Computer Science and Math overlap enough that a common track for students to take is CS Major + Math Minor (or the opposite). One semester in and I realized, that wasn't me.</p><p>Second semester rolls around and I decide to take 2 math courses. Calc II and Linear Algebra. Calc II was easier than Calc I for me (maybe it was the professor). I enjoyed it, but not enough to change my mind on getting a Math minor. That change of mind came from Linear Algebra.</p><p>Linear Algebra changed my college career. I find it interesting that although I enjoy Applied Math (Computer Science), it was abstract math (Linear Algebra) which won my love.</p><p>That semester I changed my college path. I was going to double major.</p><p>Since that linear class I've taken: Multi-variable Calc, Vector Calc, Abstract Algebra, Number Theory, Stat I, Stat II</p><p>It probably wouldn't shock you if I told you my favorites were: Abstract Algebra and Number Theory.</p><p>So with that background on me, let's get into the idea behind this blog</p><h2>The idea behind this blog</h2><p>Recently I picked up my Linear Algebra textbook. I read it once a week, slowly making my way through it again. Being slighlty more confident in writing Cpp I found myself thinking about how I would program Gaussian Elimination, Matrix Multiplication, etc. I thought, maybe I should write a cpp linear algebra library. I know professional ones exist but I've always been one of those people who learns best from doing.</p><p>This blog is my attempt to share my journey writing math libraries in cpp. I will work through my favorite math textbooks, implementing the mathematical algorithms/concepts in code when I see fit.</p><p>I will add a disclaimer that I won't be looking to necessarily write the most efficient or beauitful code. That can always come later.</p><p>That being said, feedback and comments are always welcome!</p><p>-- Ehud A.</p>]]></content:encoded></item></channel></rss>