<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="og:site_name" content="Ramble Ramble"/><link rel="canonical" href="blog.ehudadler.com/swift/cxx-interop-flow"/><meta name="twitter:url" content="blog.ehudadler.com/swift/cxx-interop-flow"/><meta name="og:url" content="blog.ehudadler.com/swift/cxx-interop-flow"/><title>.cpp/.h to Swift AST Flow | Ramble Ramble</title><meta name="twitter:title" content=".cpp/.h to Swift AST Flow | Ramble Ramble"/><meta name="og:title" content=".cpp/.h to Swift AST Flow | Ramble Ramble"/><meta name="description" content="The flow that cpp files take to get read and processed by the swift compiler"/><meta name="twitter:description" content="The flow that cpp files take to get read and processed by the swift compiler"/><meta name="og:description" content="The flow that cpp files take to get read and processed by the swift compiler"/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/styles.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/favicon.png" type="image/png"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to Ramble Ramble"/></head><body class="item-page"><header><div class="wrapper"><a class="site-name" href="/">Ramble Ramble</a><p>Learning everyday</p><nav><ul><li><a href="/general">General</a></li><li><a href="/linear">Linear Algebra</a></li><li><a href="/interview">Interview Questions</a></li><li><a href="/bigdata">Algorithms for Big Data</a></li><li><a href="/finance">Finance and Economics</a></li><li><a class="selected" href="/swift">Swift Compiler</a></li></ul></nav></div></header><div class="wrapper"><article><div class="content"><h1>.cpp/.h to Swift AST Flow</h1><p>In order for the swift compiler to properly understand cxx it needs to be able to read and process <code>.cpp</code> and <code>.h</code> files. Instead of writing all the code necessary to do this, the swift compiler embeds into itself the clang compiler (<a href="https://github.com/llvm/llvm-project/tree/main/clang">clang</a> is llvm backed CXX compiler which is also written in CXX). It then needs to map the created clang AST (<a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">Abstract Syntax Tree</a>) into a valid swift AST.</p><p>We will start the journey of interop in the <code>ClangImporter.cpp</code> class found <a href="https://github.com/apple/swift/blob/3d950362b42650534377013f5f310647b709d6a2/lib/ClangImporter/ClangImporter.cpp">here</a>.</p><p>This file is long (just shy of 6k lines!) but in essence it’s the orchestrator for cxx interop.</p><h2>ClangImporter</h2><p>Like many classes in the swift compiler, <code>ClangImporter</code> has a <code>create</code> method which is used to actually build the class (its actual constructor is <code>private</code>). We can find this method <a href="https://github.com/apple/swift/blob/3d950362b42650534377013f5f310647b709d6a2/lib/ClangImporter/ClangImporter.cpp#L1199">here</a> (<a href="https://github.com/apple/swift/blob/3d950362b42650534377013f5f310647b709d6a2/include/swift/ClangImporter/ClangImporter.h#L168">.h here</a>). Here is the signature:</p><pre><code><div class="highlight"><span></span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ClangImporter</span><span class="o">&gt;</span>
<span class="n">ClangImporter</span><span class="o">::</span><span class="n">create</span><span class="p">(</span>
  <span class="n">ASTContext</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="p">,</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">swiftPCHHash</span><span class="p">,</span> 
  <span class="n">DependencyTracker</span> <span class="o">*</span><span class="n">tracker</span><span class="p">,</span>
  <span class="n">DWARFImporterDelegate</span> <span class="o">*</span><span class="n">dwarfImporterDelegate</span>
<span class="p">)</span>
</div></code></pre><p>Looking at this method may seem scary as all but 1 of the passed in arguments seem foreign. The three important parameters here (in regards to the importer) are the <code>ASTContext</code>, <code>DependencyTracker</code> and <code>DWARFImporterDelegate</code> . All 3 are used in the first line of the function to create the actual <code>ClangImporter</code></p><pre><code><div class="highlight"><span></span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ClangImporter</span><span class="o">&gt;</span> <span class="n">importer</span><span class="p">{</span>
    <span class="k">new</span> <span class="n">ClangImporter</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">tracker</span><span class="p">,</span> <span class="n">dwarfImporterDelegate</span><span class="p">)};</span>
</div></code></pre><p><strong>ASTContext (<a href="https://github.com/apple/swift/blob/3d950362b42650534377013f5f310647b709d6a2/include/swift/ClangImporter/ClangImporter.h#L154">docstring</a>)</strong></p><p>We will go into this more in the future but I want to give a quick rundown on what the <code>ASTContext</code> is given how important it is in the swift compiler.</p><p>In swift, when creating global/static variables, you generally need to store them in a “Context“ (Think <a href="https://stackoverflow.com/questions/12825148/what-is-the-meaning-of-the-term-arena-in-relation-to-memory">Arena allocation</a>). In our case we are passing in an ASTContext (meaning this Context will exist while the swift AST exists). A Context‘s job is to allocate memory for new objects and keep objects ”alive“ until the Context itself is destroyed at which time all objects added to the context are destroyed as well.</p><p>For example, in swift, strings are generally stored in an object called a <code>StringRef</code> instead of an <code>std::string</code>. A <code>StringRef</code> acts like <code>std::string</code> but its lifetime is determined by the “Context” which it belongs to. For that reason creating a <code>StringRef</code> and not assigning it to a context is akin to a “dangling pointer“. Swift makes creating certain objects easy, for example: <code>ASTContext::getIdentifier(StringRef)</code> which will create an <code>Identifier</code> and assign it to the <code>ASTContext</code> for you.</p><p><strong>DependencyTracker (<a href="https://github.com/apple/swift/blob/3d950362b42650534377013f5f310647b709d6a2/include/swift/ClangImporter/ClangImporter.h#L160">docstring</a>)</strong></p><p>Generally created in frontend.cpp <a href="https://github.com/apple/swift/blob/3d950362b42650534377013f5f310647b709d6a2/lib/Frontend/Frontend.cpp#L336">here</a> the dependency tracker is used to help use find other modules which the current module we are compiling depend on.</p><p><strong>DWARFImporterDelegate (<a href="https://github.com/apple/swift/blob/3d950362b42650534377013f5f310647b709d6a2/include/swift/ClangImporter/ClangImporter.h#L162">docstring</a>)</strong></p><p>DWARF (Debugging With Arbitrary Record Format) is a file format used by debuggers. This delegate is used to synthesize clang Decls from debug info.</p><h3>How ClangImporter is used</h3><p>The <code>ClangImporter</code> inherits from ClangModuleLoader (<a href="https://github.com/apple/swift/blob/3d950362b42650534377013f5f310647b709d6a2/include/swift/ClangImporter/ClangImporter.h#L126">here</a>) which inherits from ModuleLoader (<a href="https://github.com/apple/swift/blob/3d950362b42650534377013f5f310647b709d6a2/include/swift/AST/ClangModuleLoader.h#L116">here</a>). This is important because now that <code>ClangImporter</code> inherits from ModuleLoader, it can be added (<a href="https://github.com/apple/swift/blob/3d950362b42650534377013f5f310647b709d6a2/include/swift/AST/ASTContext.h#L972">using ASTContext::<code>addModuleLoader</code></a>) to the <code>ASTContext</code> like other ModuleLoaders.</p><p>We now have a better picture of how cxx interop fits into the Swift compiler. When adding cxx interop the idea was to add a new <code>ModuleLoader</code> which understood cxx and could return swift versions of those cxx decls when requested (ClangModuleLoader). Adding new ModuleLoaders occurs <a href="https://github.com/apple/swift/blob/3d950362b42650534377013f5f310647b709d6a2/lib/Frontend/Frontend.cpp#L487">here</a> in <code>frontend.cpp,</code> our <code>ClangImporter::create</code> function occurs a few lines later (<a href="https://github.com/apple/swift/blob/3d950362b42650534377013f5f310647b709d6a2/lib/Frontend/Frontend.cpp#L527">here</a>) and finally it is added as a module loader <a href="https://github.com/apple/swift/blob/3d950362b42650534377013f5f310647b709d6a2/lib/Frontend/Frontend.cpp#L574">here</a>. ASTContext exposes the clang module loader explicitly using <code>ClangModuleLoader ASTContext::getClangModuleLoader</code> which in turn exposes all the necessary methods for perform interop to the rest of the swift compiler!</p></div><span>Tagged with: </span><ul class="tag-list"><li><a href="/tags/article">article</a></li><li><a href="/tags/swift">swift</a></li><li><a href="/tags/cpp">cpp</a></li><li><a href="/tags/interop">interop</a></li><li><a href="/tags/interopability">interopability</a></li></ul></article></div><footer><p>Generated using <a href="https://github.com/johnsundell/publish">Publish</a></p><p><a href="/feed.rss">RSS feed</a></p></footer></body></html>